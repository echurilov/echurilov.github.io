{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./node_modules/delaunator/index.js","webpack:///./node_modules/d3-delaunay/src/path.js","webpack:///./node_modules/d3-delaunay/src/polygon.js","webpack:///./node_modules/d3-delaunay/src/voronoi.js","webpack:///./node_modules/d3-delaunay/src/delaunay.js","webpack:///./assets/js/solovoi.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","EPSILON","Math","pow","Delaunator","[object Object]","points","getX","getY","defaultGetX","defaultGetY","length","coords","Float64Array","minX","Infinity","minY","maxX","maxY","ids","this","Uint32Array","Error","x","y","cx","cy","i0","i1","i2","minDist","dist","i0x","i0y","i1x","i1y","minRadius","circumradius","i2x","i2y","orient","center","ax","ay","bx","by","dx","dy","ex","ey","bl","cl","circumcenter","_cx","_cy","quicksort","left","right","j","temp","compare","median","swap","_hashSize","ceil","sqrt","_hash","Array","e","hull","insertNode","_hashEdge","maxTriangles","triangles","halfedges","Int32Array","trianglesLen","_addTriangle","xp","yp","k","abs","startKey","_hashKey","start","removed","prev","next","walkBack","_legalize","q","removeNode","subarray","floor","pseudoAngle","a","b","a0","b0","al","ar","p0","pr","pl","p1","px","py","fx","fy","bp","cp","inCircle","hbl","_link","br","qx","qy","rx","ry","node","arr","tmp","epsilon","Path","_x0","_y0","_x1","_y1","_","x0","y0","w","h","Polygon","push","slice","voronoi_Voronoi","delaunay","xmin","ymin","xmax","ymax","circumcenters","vectors","t1","t2","t3","x1","y1","x2","y2","x3","y3","a2","a3","b2","b3","d1","d2","d3","ab","context","buffer","undefined","ti","tj","xi","yi","xj","yj","_renderSegment","v","_project","rect","_clip","moveTo","lineTo","closePath","cell","cellPolygon","polygon","renderCell","S","c0","_regioncode","c1","_clipSegment","_step","inedges","e0","_cell","V","_clipInfinite","_clipFinite","e1","P","sx0","sy0","sx1","sy1","_edgecode","_edge","contains","vx0","vy0","vxn","vyn","from","unshift","splice","vx","vy","tau","PI","delaunay_Delaunay","fill","outedges","node0","node1","bounds","dc","neighbors","dt","renderHull","arc","t0","trianglePolygon","renderTriangle","that","array","flatArray","flatIterable","Cell","voronoi","_this","_classCallCheck","id","path","Path2D","red","green","blue","alpha","border","_toConsumableArray","filter","borders","_this2","some","_ref","_ref2","_slicedToArray","_ref3","_ref4","x_","y_","document","addEventListener","canvasEl","getElementById","ctx","getContext","width","self","innerWidth","height","innerHeight","cellCount","random","Delaunay","render","fillStyle","fillRect","lineCap","strokeStyle","lineWidth","stroke","allCells","fillCell","concat","highlightCell","fillColor","borderColor","prevHoverCell","currentHoverCell","painting","mouseButton","mousePos","getBoundingClientRect","clientX","clientY","top","getMousePos","_i3","mouse","preventDefault","button","window","setInterval","rednesses","_i4","reduce","sum","neighbor"],"mappings":"aACA,IAAAA,KAGA,SAAAC,EAAAC,GAGA,GAAAF,EAAAE,GACA,OAAAF,EAAAE,GAAAC,QAGA,IAAAC,EAAAJ,EAAAE,IACAG,EAAAH,EACAI,GAAA,EACAH,YAUA,OANAI,EAAAL,GAAAM,KAAAJ,EAAAD,QAAAC,IAAAD,QAAAF,GAGAG,EAAAE,GAAA,EAGAF,EAAAD,QAKAF,EAAAQ,EAAAF,EAGAN,EAAAS,EAAAV,EAGAC,EAAAU,EAAA,SAAAR,EAAAS,EAAAC,GACAZ,EAAAa,EAAAX,EAAAS,IACAG,OAAAC,eAAAb,EAAAS,GAA0CK,YAAA,EAAAC,IAAAL,KAK1CZ,EAAAkB,EAAA,SAAAhB,GACA,oBAAAiB,eAAAC,aACAN,OAAAC,eAAAb,EAAAiB,OAAAC,aAAwDC,MAAA,WAExDP,OAAAC,eAAAb,EAAA,cAAiDmB,OAAA,KAQjDrB,EAAAsB,EAAA,SAAAD,EAAAE,GAEA,GADA,EAAAA,IAAAF,EAAArB,EAAAqB,IACA,EAAAE,EAAA,OAAAF,EACA,KAAAE,GAAA,iBAAAF,QAAAG,WAAA,OAAAH,EACA,IAAAI,EAAAX,OAAAY,OAAA,MAGA,GAFA1B,EAAAkB,EAAAO,GACAX,OAAAC,eAAAU,EAAA,WAAyCT,YAAA,EAAAK,UACzC,EAAAE,GAAA,iBAAAF,EAAA,QAAAM,KAAAN,EAAArB,EAAAU,EAAAe,EAAAE,EAAA,SAAAA,GAAgH,OAAAN,EAAAM,IAAqBC,KAAA,KAAAD,IACrI,OAAAF,GAIAzB,EAAA6B,EAAA,SAAA1B,GACA,IAAAS,EAAAT,KAAAqB,WACA,WAA2B,OAAArB,EAAA,SAC3B,WAAiC,OAAAA,GAEjC,OADAH,EAAAU,EAAAE,EAAA,IAAAA,GACAA,GAIAZ,EAAAa,EAAA,SAAAiB,EAAAC,GAAsD,OAAAjB,OAAAkB,UAAAC,eAAA1B,KAAAuB,EAAAC,IAGtD/B,EAAAkC,EAAA,GAIAlC,IAAAmC,EAAA,yCCjFA,MAAAC,EAAAC,KAAAC,IAAA,aAEeC,EAEfC,YAAAC,EAAAC,EAAAC,GACAD,MAAAE,GACAD,MAAAE,GAEA,MAAAhB,EAAAY,EAAAK,OACAC,EAAA,IAAAC,aAAA,EAAAnB,GAEA,QAAAzB,EAAA,EAAuBA,EAAAyB,EAAOzB,IAAA,CAC9B,MAAA8B,EAAAO,EAAArC,GACA2C,EAAA,EAAA3C,GAAAsC,EAAAR,GACAa,EAAA,EAAA3C,EAAA,GAAAuC,EAAAT,GAGA,WAAAK,EAAAQ,GAGAP,YAAAO,GACA,IAAAE,EAAAC,IACAC,EAAAD,IACAE,GAAAF,IACAG,GAAAH,IAEA,MAAArB,EAAAkB,EAAAD,QAAA,EACAQ,EAAAC,KAAAD,IAAA,IAAAE,YAAA3B,GAEA,GAAAA,EAAA,oBAAAkB,EAAA,aAAAU,MAAA,uCAEAF,KAAAR,SAEA,QAAA3C,EAAA,EAAuBA,EAAAyB,EAAOzB,IAAA,CAC9B,MAAAsD,EAAAX,EAAA,EAAA3C,GACAuD,EAAAZ,EAAA,EAAA3C,EAAA,GACAsD,EAAAT,MAAAS,GACAC,EAAAR,MAAAQ,GACAD,EAAAN,MAAAM,GACAC,EAAAN,MAAAM,GACAL,EAAAlD,KAGA,MAAAwD,GAAAX,EAAAG,GAAA,EACAS,GAAAV,EAAAE,GAAA,EAEA,IACAS,EAAAC,EAAAC,EADAC,EAAAf,IAIA,QAAA9C,EAAA,EAAuBA,EAAAyB,EAAOzB,IAAA,CAC9B,MAAAM,EAAAwD,EAAAN,EAAAC,EAAAd,EAAA,EAAA3C,GAAA2C,EAAA,EAAA3C,EAAA,IACAM,EAAAuD,IACAH,EAAA1D,EACA6D,EAAAvD,GAGA,MAAAyD,EAAApB,EAAA,EAAAe,GACAM,EAAArB,EAAA,EAAAe,EAAA,GAEAG,EAAAf,IAGA,QAAA9C,EAAA,EAAuBA,EAAAyB,EAAOzB,IAAA,CAC9B,GAAAA,IAAA0D,EAAA,SACA,MAAApD,EAAAwD,EAAAC,EAAAC,EAAArB,EAAA,EAAA3C,GAAA2C,EAAA,EAAA3C,EAAA,IACAM,EAAAuD,GAAAvD,EAAA,IACAqD,EAAA3D,EACA6D,EAAAvD,GAGA,IAAA2D,EAAAtB,EAAA,EAAAgB,GACAO,EAAAvB,EAAA,EAAAgB,EAAA,GAEAQ,EAAArB,IAGA,QAAA9C,EAAA,EAAuBA,EAAAyB,EAAOzB,IAAA,CAC9B,GAAAA,IAAA0D,GAAA1D,IAAA2D,EAAA,SACA,MAAA7C,EAAAsD,EAAAL,EAAAC,EAAAC,EAAAC,EAAAvB,EAAA,EAAA3C,GAAA2C,EAAA,EAAA3C,EAAA,IACAc,EAAAqD,IACAP,EAAA5D,EACAmE,EAAArD,GAGA,IAAAuD,EAAA1B,EAAA,EAAAiB,GACAU,EAAA3B,EAAA,EAAAiB,EAAA,GAEA,GAAAO,IAAArB,IACA,UAAAO,MAAA,oDAIA,GAAAkB,EAAAR,EAAAC,EAAAC,EAAAC,EAAAG,EAAAC,GAAA,CACA,MAAAtE,EAAA2D,EACAL,EAAAW,EACAV,EAAAW,EACAP,EAAAC,EACAK,EAAAI,EACAH,EAAAI,EACAV,EAAA5D,EACAqE,EAAAf,EACAgB,EAAAf,EAGA,MAAAiB,EAgQA,SAAAC,EAAAC,EAAAC,EAAAC,EAAApB,EAAAC,GACA,MAAAoB,EAAAF,EAAAF,EACAK,EAAAF,EAAAF,EACAK,EAAAvB,EAAAiB,EACAO,EAAAvB,EAAAiB,EAEAO,EAAAJ,IAAAC,IACAI,EAAAH,IAAAC,IACA1E,EAAAuE,EAAAG,EAAAF,EAAAC,EAKA,OAAYzB,EAHZmB,EAAA,IAAAO,EAAAC,EAAAH,EAAAI,GAAA5E,EAGYiD,EAFZmB,EAAA,IAAAG,EAAAK,EAAAH,EAAAE,GAAA3E,GA3QA6E,CAAApB,EAAAC,EAAAC,EAAAC,EAAAG,EAAAC,GACAnB,KAAAiC,IAAAZ,EAAAlB,EACAH,KAAAkC,IAAAb,EAAAjB,EA8SA,SAAA+B,EAAApC,EAAAP,EAAA4C,EAAAC,EAAAhC,EAAAC,GACA,IAAAzD,EAAAyF,EAAAC,EAEA,GAAAF,EAAAD,GAAA,GACA,IAAAvF,EAAAuF,EAAA,EAA0BvF,GAAAwF,EAAYxF,IAAA,CAGtC,IAFA0F,EAAAxC,EAAAlD,GACAyF,EAAAzF,EAAA,EACAyF,GAAAF,GAAAI,EAAAhD,EAAAO,EAAAuC,GAAAC,EAAAlC,EAAAC,GAAA,GAAAP,EAAAuC,EAAA,GAAAvC,EAAAuC,KACAvC,EAAAuC,EAAA,GAAAC,MAEK,CACL,MAAAE,EAAAL,EAAAC,GAAA,EASA,IAPAC,EAAAD,EACAK,EAAA3C,EAAA0C,EAFA5F,EAAAuF,EAAA,GAGAI,EAAAhD,EAAAO,EAAAqC,GAAArC,EAAAsC,GAAAhC,EAAAC,GAAA,GAAAoC,EAAA3C,EAAAqC,EAAAC,GACAG,EAAAhD,EAAAO,EAAAlD,GAAAkD,EAAAsC,GAAAhC,EAAAC,GAAA,GAAAoC,EAAA3C,EAAAlD,EAAAwF,GACAG,EAAAhD,EAAAO,EAAAqC,GAAArC,EAAAlD,GAAAwD,EAAAC,GAAA,GAAAoC,EAAA3C,EAAAqC,EAAAvF,GAEA0F,EAAAxC,EAAAlD,KACA,CACA,GAAAA,UAAmB2F,EAAAhD,EAAAO,EAAAlD,GAAA0F,EAAAlC,EAAAC,GAAA,GACnB,GAAAgC,UAAmBE,EAAAhD,EAAAO,EAAAuC,GAAAC,EAAAlC,EAAAC,GAAA,GACnB,GAAAgC,EAAAzF,EAAA,MACA6F,EAAA3C,EAAAlD,EAAAyF,GAEAvC,EAAAqC,EAAA,GAAArC,EAAAuC,GACAvC,EAAAuC,GAAAC,EAEAF,EAAAxF,EAAA,GAAAyF,EAAAF,GACAD,EAAApC,EAAAP,EAAA3C,EAAAwF,EAAAhC,EAAAC,GACA6B,EAAApC,EAAAP,EAAA4C,EAAAE,EAAA,EAAAjC,EAAAC,KAEA6B,EAAApC,EAAAP,EAAA4C,EAAAE,EAAA,EAAAjC,EAAAC,GACA6B,EAAApC,EAAAP,EAAA3C,EAAAwF,EAAAhC,EAAAC,KA7UA6B,CAAApC,EAAAP,EAAA,EAAAO,EAAAR,OAAA,EAAA8B,EAAAlB,EAAAkB,EAAAjB,GAGAJ,KAAA2C,UAAA7D,KAAA8D,KAAA9D,KAAA+D,KAAAvE,IACA0B,KAAA8C,MAAA,IAAAC,MAAA/C,KAAA2C,WAGA,IAAAK,EAAAhD,KAAAiD,KAAAC,EAAA1D,EAAAe,GACAP,KAAAmD,UAAAH,GACAA,EAAAjF,EAAA,EACAiF,EAAAE,EAAA1D,EAAAgB,EAAAwC,GACAhD,KAAAmD,UAAAH,GACAA,EAAAjF,EAAA,EACAiF,EAAAE,EAAA1D,EAAAiB,EAAAuC,GACAhD,KAAAmD,UAAAH,GACAA,EAAAjF,EAAA,EAEA,MAAAqF,EAAA,EAAA9E,EAAA,EACA+E,EAAArD,KAAAqD,UAAA,IAAApD,YAAA,EAAAmD,GACAE,EAAAtD,KAAAsD,UAAA,IAAAC,WAAA,EAAAH,GAEApD,KAAAwD,aAAA,EAEAxD,KAAAyD,aAAAlD,EAAAC,EAAAC,GAAA,SAEA,QAAAiD,EAAAC,EAAAC,EAAA,EAA+BA,EAAA7D,EAAAR,OAAgBqE,IAAA,CAC/C,MAAA/G,EAAAkD,EAAA6D,GACAzD,EAAAX,EAAA,EAAA3C,GACAuD,EAAAZ,EAAA,EAAA3C,EAAA,GAGA,GAAA+G,EAAA,GAAA9E,KAAA+E,IAAA1D,EAAAuD,IAAA7E,GAAAC,KAAA+E,IAAAzD,EAAAuD,IAAA9E,EAAA,SAKA,GAJA6E,EAAAvD,EACAwD,EAAAvD,EAGAvD,IAAA0D,GAAA1D,IAAA2D,GAAA3D,IAAA4D,EAAA,SAGA,MAAAqD,EAAA9D,KAAA+D,SAAA5D,EAAAC,GACA,IACA4D,EADA5F,EAAA0F,EAEA,GACAE,EAAAhE,KAAA8C,MAAA1E,GACAA,KAAA,GAAA4B,KAAA2C,kBACaqB,KAAAC,UAAA7F,IAAA0F,GAIb,IADAd,EADAgB,IAAAE,MAEA9C,EAAAjB,EAAAC,EAAA4C,EAAA7C,EAAA6C,EAAA5C,EAAA4C,EAAAmB,KAAAhE,EAAA6C,EAAAmB,KAAA/D,IAEA,IADA4C,IAAAmB,QACAH,EAAA,CACAhB,EAAA,KACA,MAIA,IAAAA,EAAA,SAEA,MAAAoB,EAAApB,IAAAgB,EAGA,IAAAjG,EAAAiC,KAAAyD,aAAAT,EAAAnG,IAAAmG,EAAAmB,KAAAtH,GAAA,KAAAmG,EAAAjF,GAEAiF,EAAAjF,KACAiF,EAAAE,EAAA1D,EAAA3C,EAAAmG,IAGAjF,EAAAiC,KAAAqE,UAAAtG,EAAA,GAGA,IAAAuG,EAAAtB,EAAAmB,KACA,KAAA/C,EAAAjB,EAAAC,EAAAkE,EAAAnE,EAAAmE,EAAAlE,EAAAkE,EAAAH,KAAAhE,EAAAmE,EAAAH,KAAA/D,IACArC,EAAAiC,KAAAyD,aAAAa,EAAAzH,IAAAyH,EAAAH,KAAAtH,EAAAyH,EAAAJ,KAAAnG,GAAA,EAAAuG,EAAAvG,GACAuG,EAAAJ,KAAAnG,EAAAiC,KAAAqE,UAAAtG,EAAA,GACAiC,KAAAiD,KAAAsB,EAAAD,GACAA,IAAAH,KAGA,GAAAC,EAGA,IADAE,EAAAtB,EAAAkB,KACA9C,EAAAjB,EAAAC,EAAAkE,EAAAJ,KAAA/D,EAAAmE,EAAAJ,KAAA9D,EAAAkE,EAAAnE,EAAAmE,EAAAlE,IACArC,EAAAiC,KAAAyD,aAAAa,EAAAJ,KAAArH,IAAAyH,EAAAzH,GAAA,EAAAyH,EAAAvG,EAAAuG,EAAAJ,KAAAnG,GACAiC,KAAAqE,UAAAtG,EAAA,GACAuG,EAAAJ,KAAAnG,IACAiC,KAAAiD,KAAAsB,EAAAD,GACAA,IAAAJ,KAKAlE,KAAAmD,UAAAH,GACAhD,KAAAmD,UAAAH,EAAAkB,MAIAlE,KAAAqD,YAAAmB,SAAA,EAAAxE,KAAAwD,cACAxD,KAAAsD,YAAAkB,SAAA,EAAAxE,KAAAwD,cAGAvE,UAAA+D,GACAhD,KAAA8C,MAAA9C,KAAA+D,SAAAf,EAAA7C,EAAA6C,EAAA5C,IAAA4C,EAGA/D,SAAAkB,EAAAC,GACA,OAAAtB,KAAA2F,MAiGA,SAAA/C,EAAAC,GACA,MAAAhD,EAAA+C,GAAA5C,KAAA+E,IAAAnC,GAAA5C,KAAA+E,IAAAlC,IACA,OAAAA,EAAA,IAAAhD,EAAA,EAAAA,GAAA,EAnGA+F,CAAAvE,EAAAH,KAAAiC,IAAA7B,EAAAJ,KAAAkC,KAAAlC,KAAA2C,WAAA3C,KAAA2C,UAGA1D,UAAA0F,GACA,MAAAtB,UAAeA,EAAA7D,SAAA8D,aAA6BtD,KAE5C4E,EAAAtB,EAAAqB,GAiBAE,EAAAF,IAAA,EACAG,EAAAF,IAAA,EAEAG,EAAAF,GAAAF,EAAA,KACAK,EAAAH,GAAAF,EAAA,KACA7C,EAAAgD,GAAAF,EAAA,KAEA,QAAAA,EAAA,OAAAI,EAEA,MAAAC,EAAA5B,EAAA2B,GACAE,EAAA7B,EAAAsB,GACAQ,EAAA9B,EAAA0B,GACAK,EAAA/B,EAAAvB,GAQA,GAqEA,SAAAR,EAAAC,EAAAC,EAAAC,EAAApB,EAAAC,EAAA+E,EAAAC,GACA,MAAA5D,EAAAJ,EAAA+D,EACA1D,EAAAJ,EAAA+D,EACA1D,EAAAJ,EAAA6D,EACAxD,EAAAJ,EAAA6D,EACAC,EAAAlF,EAAAgF,EACAG,EAAAlF,EAAAgF,EAGAG,EAAA7D,IAAAC,IACA6D,EAAAH,IAAAC,IAEA,OAAA9D,GAAAG,EAAA6D,EAAAD,EAAAD,GACA7D,GAAAC,EAAA8D,EAAAD,EAAAF,IALA7D,IAAAC,MAMAC,EAAA4D,EAAA3D,EAAA0D,GAAA,EAzFAI,CACAnG,EAAA,EAAAyF,GAAAzF,EAAA,EAAAyF,EAAA,GACAzF,EAAA,EAAA0F,GAAA1F,EAAA,EAAA0F,EAAA,GACA1F,EAAA,EAAA2F,GAAA3F,EAAA,EAAA2F,EAAA,GACA3F,EAAA,EAAA4F,GAAA5F,EAAA,EAAA4F,EAAA,IAEA,CACA/B,EAAAsB,GAAAS,EACA/B,EAAAuB,GAAAK,EAEA,MAAAW,EAAAtC,EAAAxB,GAGA,QAAA8D,EAAA,CACA,IAAA5C,EAAAhD,KAAAiD,KACA,GACA,GAAAD,EAAAjF,IAAA+D,EAAA,CACAkB,EAAAjF,EAAA4G,EACA,MAEA3B,IAAAmB,WACiBnB,IAAAhD,KAAAiD,MAEjBjD,KAAA6F,MAAAlB,EAAAiB,GACA5F,KAAA6F,MAAAjB,EAAAtB,EAAA0B,IACAhF,KAAA6F,MAAAb,EAAAlD,GAEA,MAAAgE,EAAAhB,GAAAF,EAAA,KAGA,OADA5E,KAAAqE,UAAAM,GACA3E,KAAAqE,UAAAyB,GAGA,OAAAd,EAGA/F,MAAA0F,EAAAC,GACA5E,KAAAsD,UAAAqB,GAAAC,GACA,IAAAA,IAAA5E,KAAAsD,UAAAsB,GAAAD,GAIA1F,aAAAsB,EAAAC,EAAAC,EAAAkE,EAAAC,EAAA1H,GACA,MAAAa,EAAAiC,KAAAwD,aAYA,OAVAxD,KAAAqD,UAAAtF,GAAAwC,EACAP,KAAAqD,UAAAtF,EAAA,GAAAyC,EACAR,KAAAqD,UAAAtF,EAAA,GAAA0C,EAEAT,KAAA6F,MAAA9H,EAAA4G,GACA3E,KAAA6F,MAAA9H,EAAA,EAAA6G,GACA5E,KAAA6F,MAAA9H,EAAA,EAAAb,GAEA8C,KAAAwD,cAAA,EAEAzF,GAUA,SAAA4C,EAAAW,EAAAC,EAAAC,EAAAC,GACA,MAAAC,EAAAJ,EAAAE,EACAG,EAAAJ,EAAAE,EACA,OAAAC,IAAAC,IAGA,SAAAP,EAAAiE,EAAAC,EAAAS,EAAAC,EAAAC,EAAAC,GACA,OAAAF,EAAAV,IAAAW,EAAAF,MAAAV,IAAAa,EAAAF,GAAA,EAoBA,SAAA/E,EAAAK,EAAAC,EAAAC,EAAAC,EAAApB,EAAAC,GACA,MAAAoB,EAAAF,EAAAF,EACAK,EAAAF,EAAAF,EACAK,EAAAvB,EAAAiB,EACAO,EAAAvB,EAAAiB,EAEAO,EAAAJ,IAAAC,IACAI,EAAAH,IAAAC,IACA1E,EAAAuE,EAAAG,EAAAF,EAAAC,EAEAzB,EAAA,IAAA0B,EAAAC,EAAAH,EAAAI,GAAA5E,EACAiD,EAAA,IAAAsB,EAAAK,EAAAH,EAAAE,GAAA3E,EAEA,OAAA2E,GAAAC,GAAA5E,GAAAgD,IAAAC,KAAAT,IAoBA,SAAAuD,EAAA1D,EAAA3C,EAAAqH,GACA,MAAAiC,GACAtJ,IACAsD,EAAAX,EAAA,EAAA3C,GACAuD,EAAAZ,EAAA,EAAA3C,EAAA,GACAkB,EAAA,EACAmG,KAAA,KACAC,KAAA,KACAF,SAAA,GAaA,OAVAC,GAKAiC,EAAAhC,KAAAD,EAAAC,KACAgC,EAAAjC,OACAA,EAAAC,KAAAD,KAAAiC,EACAjC,EAAAC,KAAAgC,IAPAA,EAAAjC,KAAAiC,EACAA,EAAAhC,KAAAgC,GAQAA,EAGA,SAAA5B,EAAA4B,GAIA,OAHAA,EAAAjC,KAAAC,KAAAgC,EAAAhC,KACAgC,EAAAhC,KAAAD,KAAAiC,EAAAjC,KACAiC,EAAAlC,SAAA,EACAkC,EAAAjC,KA0CA,SAAA1B,EAAAhD,EAAA3C,EAAAyF,EAAAjC,EAAAC,GAGA,OAFAK,EAAAnB,EAAA,EAAA3C,GAAA2C,EAAA,EAAA3C,EAAA,GAAAwD,EAAAC,GACAK,EAAAnB,EAAA,EAAA8C,GAAA9C,EAAA,EAAA8C,EAAA,GAAAjC,EAAAC,IACAd,EAAA,EAAA3C,GAAA2C,EAAA,EAAA8C,IAAA9C,EAAA,EAAA3C,EAAA,GAAA2C,EAAA,EAAA8C,EAAA,GAGA,SAAAI,EAAA0D,EAAAvJ,EAAAyF,GACA,MAAA+D,EAAAD,EAAAvJ,GACAuJ,EAAAvJ,GAAAuJ,EAAA9D,GACA8D,EAAA9D,GAAA+D,EAGA,SAAAhH,EAAAV,GACA,OAAAA,EAAA,GAEA,SAAAW,EAAAX,GACA,OAAAA,EAAA,GCjdA,MAAA2H,EAAA,WAEeC,EACftH,cACAe,KAAAwG,IAAAxG,KAAAyG,IACAzG,KAAA0G,IAAA1G,KAAA2G,IAAA,KACA3G,KAAA4G,EAAA,GAEA3H,OAAAkB,EAAAC,GACAJ,KAAA4G,OAAkB5G,KAAAwG,IAAAxG,KAAA0G,KAAAvG,KAA4BH,KAAAyG,IAAAzG,KAAA2G,KAAAvG,IAE9CnB,YACA,OAAAe,KAAA0G,MACA1G,KAAA0G,IAAA1G,KAAAwG,IAAAxG,KAAA2G,IAAA3G,KAAAyG,IACAzG,KAAA4G,GAAA,KAGA3H,OAAAkB,EAAAC,GACAJ,KAAA4G,OAAkB5G,KAAA0G,KAAAvG,KAAiBH,KAAA2G,KAAAvG,IAEnCnB,IAAAkB,EAAAC,EAAAzC,GAEA,MAAAkJ,GADA1G,OAAAxC,MAEAmJ,EAFA1G,KAGA,GAAAzC,EAAA,YAAAuC,MAAA,mBACA,OAAAF,KAAA0G,IAAA1G,KAAA4G,OAAyCC,KAAMC,KAC/ChI,KAAA+E,IAAA7D,KAAA0G,IAAAG,GAAAP,GAAAxH,KAAA+E,IAAA7D,KAAA2G,IAAAG,GAAAR,KAAAtG,KAAA4G,GAAA,IAAAC,EAAA,IAAAC,GACAnJ,IACAqC,KAAA4G,OAAkBjJ,KAAKA,WAAWwC,EAAAxC,KAASyC,KAAKzC,KAAKA,WAAWqC,KAAA0G,IAAAG,KAAiB7G,KAAA2G,IAAAG,KAEjF7H,KAAAkB,EAAAC,EAAA2G,EAAAC,GACAhH,KAAA4G,OAAkB5G,KAAAwG,IAAAxG,KAAA0G,KAAAvG,KAA4BH,KAAAyG,IAAAzG,KAAA2G,KAAAvG,MAA4B2G,MAAMC,MAAMD,KAEtF9H,QACA,OAAAe,KAAA4G,GAAA,YClCeK,EACfhI,cACAe,KAAA4G,KAEA3H,OAAAkB,EAAAC,GACAJ,KAAA4G,EAAAM,MAAA/G,EAAAC,IAEAnB,YACAe,KAAA4G,EAAAM,KAAAlH,KAAA4G,EAAA,GAAAO,SAEAlI,OAAAkB,EAAAC,GACAJ,KAAA4G,EAAAM,MAAA/G,EAAAC,IAEAnB,QACA,OAAAe,KAAA4G,EAAArH,OAAAS,KAAA4G,EAAA,YCXqBQ,EACrBnI,YAAAoI,GAAAC,EAAAC,EAAAC,EAAAC,IAAA,cACA,MAAAD,QAAAF,QAAAG,QAAAF,OAAA,UAAArH,MAAA,kBACA,MAAAhB,OAAWA,EAAA+D,OAAAI,aAAwBrD,KAAAqH,WACnCK,EAAA1H,KAAA0H,cAAA,IAAAjI,aAAA4D,EAAA9D,OAAA,KACAoI,EAAA3H,KAAA2H,QAAA,IAAAlI,aAAA,EAAAP,EAAAK,QACAS,KAAAwH,OAAAxH,KAAAsH,OACAtH,KAAAyH,OAAAzH,KAAAuH,OAGA,QAAA1K,EAAA,EAAAyF,EAAA,EAAAhE,EAAA+E,EAAA9D,OAAgD1C,EAAAyB,EAAOzB,GAAA,EAAAyF,GAAA,GACvD,MAAAsF,EAAA,EAAAvE,EAAAxG,GACAgL,EAAA,EAAAxE,EAAAxG,EAAA,GACAiL,EAAA,EAAAzE,EAAAxG,EAAA,GACAkL,EAAA7I,EAAA0I,GACAI,EAAA9I,EAAA0I,EAAA,GACAK,EAAA/I,EAAA2I,GACAK,EAAAhJ,EAAA2I,EAAA,GACAM,EAAAjJ,EAAA4I,GACAM,EAAAlJ,EAAA4I,EAAA,GACAO,EAAAN,EAAAE,EACAK,EAAAP,EAAAI,EACAI,EAAAP,EAAAE,EACAM,EAAAR,EAAAI,EACAK,EAAAV,IAAAC,IACAU,EAAAD,EAAAR,IAAAC,IACAS,EAAAF,EAAAN,IAAAC,IACAQ,EAAA,GAAAN,EAAAC,EAAAF,EAAAG,GACAd,EAAApF,IAAAiG,EAAAI,EAAAH,EAAAE,GAAAE,EACAlB,EAAApF,EAAA,IAAAgG,EAAAI,EAAAL,EAAAM,GAAAC,EAIA,IACA3D,EACA4B,EACAC,EAHAX,EAAAlD,EACAmC,EAAA,EAAAe,EAAAtJ,EACAkL,EAAA5B,EAAAhG,EACA6H,EAAA7B,EAAA/F,EACA,GACA6E,EAAAG,EAAAyB,EAAAkB,EAAAjB,EAAAkB,EAAA5C,EAAA,GAAAe,IAAAhC,MAAAtH,EAAAkL,EAAA5B,EAAAhG,EAAA6H,EAAA7B,EAAA/F,EACAuH,EAAA1C,EAAA,GAAA0C,EAAAvC,GAAA0B,EAAAkB,EACAL,EAAA1C,EAAA,GAAA0C,EAAAvC,EAAA,GAAA2C,EAAAlB,QACKV,IAAAlD,GAELhE,OAAA4J,GACA,MAAAC,EAAA,MAAAD,IAAA,IAAmDtC,OAAIwC,GAC5C1B,UAAA/D,UAAWA,EAAAL,QAAgByE,gBAAAC,WAAyB3H,KAC/D,QAAAnD,EAAA,EAAAyB,EAAAgF,EAAA/D,OAAyC1C,EAAAyB,IAAOzB,EAAA,CAChD,MAAAyF,EAAAgB,EAAAzG,GACA,GAAAyF,EAAAzF,EAAA,SACA,MAAAmM,EAAA,EAAAlK,KAAA2F,MAAA5H,EAAA,GACAoM,EAAA,EAAAnK,KAAA2F,MAAAnC,EAAA,GACA4G,EAAAxB,EAAAsB,GACAG,EAAAzB,EAAAsB,EAAA,GACAI,EAAA1B,EAAAuB,GACAI,EAAA3B,EAAAuB,EAAA,GACAjJ,KAAAsJ,eAAAJ,EAAAC,EAAAC,EAAAC,EAAAR,GAEA,IAAA1C,EAAAlD,EACA,GACAkD,IAAAhC,KACA,MAAApG,EAAA,EAAAe,KAAA2F,MAAA0B,EAAApI,EAAA,GACAoC,EAAAuH,EAAA3J,GACAqC,EAAAsH,EAAA3J,EAAA,GACAwL,EAAA,EAAApD,EAAAtJ,EACA8B,EAAAqB,KAAAwJ,SAAArJ,EAAAC,EAAAuH,EAAA4B,EAAA,GAAA5B,EAAA4B,EAAA,IACA5K,GAAAqB,KAAAsJ,eAAAnJ,EAAAC,EAAAzB,EAAA,GAAAA,EAAA,GAAAkK,SACK1C,IAAAlD,GACL,OAAA6F,KAAAhL,QAEAmB,aAAA4J,GACA,MAAAC,EAAA,MAAAD,IAAA,IAAmDtC,OAAIwC,EAEvD,OADAF,EAAAY,KAAAzJ,KAAAsH,KAAAtH,KAAAuH,KAAAvH,KAAAwH,KAAAxH,KAAAsH,KAAAtH,KAAAyH,KAAAzH,KAAAuH,MACAuB,KAAAhL,QAEAmB,WAAApC,EAAAgM,GACA,MAAAC,EAAA,MAAAD,IAAA,IAAmDtC,OAAIwC,EACvD7J,EAAAc,KAAA0J,MAAA7M,GACA,UAAAqC,EAAA,CACA2J,EAAAc,OAAAzK,EAAA,GAAAA,EAAA,IACA,QAAArC,EAAA,EAAAyB,EAAAY,EAAAK,OAAsC1C,EAAAyB,EAAOzB,GAAA,EAC7CgM,EAAAe,OAAA1K,EAAArC,GAAAqC,EAAArC,EAAA,IAGA,OADAgM,EAAAgB,YACAf,KAAAhL,SAEAmB,gBACA,MAAWoI,UAAAnI,OAAWA,IAAQc,KAC9B,QAAAnD,EAAA,EAAAyB,EAAAY,EAAAK,OAAA,EAA0C1C,EAAAyB,IAAOzB,EAAA,CACjD,MAAAiN,EAAA9J,KAAA+J,YAAAlN,GACAiN,cAGA7K,YAAApC,GACA,MAAAmN,EAAA,IAAwB/C,EAExB,OADAjH,KAAAiK,WAAApN,EAAAmN,GACAA,EAAAlM,QAEAmB,eAAA4H,EAAAC,EAAAiB,EAAAC,EAAAa,GACA,IAAAqB,EACA,MAAAC,EAAAnK,KAAAoK,YAAAvD,EAAAC,GACAuD,EAAArK,KAAAoK,YAAArC,EAAAC,GACA,IAAAmC,GAAA,IAAAE,GACAxB,EAAAc,OAAA9C,EAAAC,GACA+B,EAAAe,OAAA7B,EAAAC,KACKkC,EAAAlK,KAAAsK,aAAAzD,EAAAC,EAAAiB,EAAAC,EAAAmC,EAAAE,MACLxB,EAAAc,OAAAO,EAAA,GAAAA,EAAA,IACArB,EAAAe,OAAAM,EAAA,GAAAA,EAAA,KAGAjL,SAAApC,EAAAsD,EAAAC,GACA,OAAAD,WAAAC,UACAJ,KAAAqH,SAAAkD,MAAA1N,EAAAsD,EAAAC,KAAAvD,EAEAoC,MAAApC,GACA,MAAA6K,cAAWA,EAAAL,UAAAmD,QAA0BA,EAAAlH,YAAAD,cAA+BrD,KACpEyK,EAAAD,EAAA3N,GACA,QAAA4N,EAAA,YACA,MAAAvL,KACA,IAAA8D,EAAAyH,EACA,GACA,MAAA1M,EAAAe,KAAA2F,MAAAzB,EAAA,GAGA,GAFA9D,EAAAgI,KAAAQ,EAAA,EAAA3J,GAAA2J,EAAA,EAAA3J,EAAA,IAEAsF,EADAL,IAAA,KAAAA,EAAA,EAAAA,EAAA,KACAnG,EAAA,MACAmG,EAAAM,EAAAN,SACKA,IAAAyH,IAAA,IAAAzH,GACL,OAAA9D,EAEAD,MAAApC,GACA,MAAAqC,EAAAc,KAAA0K,MAAA7N,GACA,UAAAqC,EAAA,YACA,MAAWyI,QAAAgD,GAAW3K,KACtBuJ,EAAA,EAAA1M,EACA,OAAA8N,EAAApB,IAAAoB,EAAApB,EAAA,GACAvJ,KAAA4K,cAAA/N,EAAAqC,EAAAyL,EAAApB,GAAAoB,EAAApB,EAAA,GAAAoB,EAAApB,EAAA,GAAAoB,EAAApB,EAAA,IACAvJ,KAAA6K,YAAAhO,EAAAqC,GAEAD,YAAApC,EAAAqC,GACA,MAAAZ,EAAAY,EAAAK,OACA,IACAsH,EAAAC,EACAqD,EACAM,EAAAK,EAHAC,EAAA,KACAhD,EAAA7I,EAAAZ,EAAA,GAAA0J,EAAA9I,EAAAZ,EAAA,GACA+L,EAAArK,KAAAoK,YAAArC,EAAAC,GAEA,QAAA1F,EAAA,EAAmBA,EAAAhE,EAAOgE,GAAA,EAG1B,GAFAuE,EAAAkB,EAAAjB,EAAAkB,EAAAD,EAAA7I,EAAAoD,GAAA0F,EAAA9I,EAAAoD,EAAA,GACA6H,EAAAE,IAAArK,KAAAoK,YAAArC,EAAAC,GACA,IAAAmC,GAAA,IAAAE,EACAI,EAAAK,IAAA,EACAC,IAAA7D,KAAAa,EAAAC,GACA+C,GAAAhD,EAAAC,OACO,CACP,IAAAkC,EAAAc,EAAAC,EAAAC,EAAAC,EACA,OAAAhB,EAAA,CACA,WAAAD,EAAAlK,KAAAsK,aAAAzD,EAAAC,EAAAiB,EAAAC,EAAAmC,EAAAE,IAAA,UACAW,EAAAC,EAAAC,EAAAC,GAAAjB,MACS,CACT,WAAAA,EAAAlK,KAAAsK,aAAAvC,EAAAC,EAAAnB,EAAAC,EAAAuD,EAAAF,IAAA,UACAe,EAAAC,EAAAH,EAAAC,GAAAf,EACAO,EAAAK,IAAA9K,KAAAoL,UAAAJ,EAAAC,GACAR,GAAAK,GAAA9K,KAAAqL,MAAAxO,EAAA4N,EAAAK,EAAAC,IAAAxL,QACAwL,IAAA7D,KAAA8D,EAAAC,GACAF,GAAAC,EAAAC,GAEAR,EAAAK,IAAA9K,KAAAoL,UAAAF,EAAAC,GACAV,GAAAK,GAAA9K,KAAAqL,MAAAxO,EAAA4N,EAAAK,EAAAC,IAAAxL,QACAwL,IAAA7D,KAAAgE,EAAAC,GACAJ,GAAAG,EAAAC,GAGA,GAAAJ,EACAN,EAAAK,IAAA9K,KAAAoL,UAAAL,EAAA,GAAAA,EAAA,IACAN,GAAAK,GAAA9K,KAAAqL,MAAAxO,EAAA4N,EAAAK,EAAAC,IAAAxL,aACK,GAAAS,KAAAsL,SAAAzO,GAAAmD,KAAAsH,KAAAtH,KAAAwH,MAAA,GAAAxH,KAAAuH,KAAAvH,KAAAyH,MAAA,GACL,OAAAzH,KAAAwH,KAAAxH,KAAAuH,KAAAvH,KAAAwH,KAAAxH,KAAAyH,KAAAzH,KAAAsH,KAAAtH,KAAAyH,KAAAzH,KAAAsH,KAAAtH,KAAAuH,MAEA,OAAAwD,EAEA9L,aAAA4H,EAAAC,EAAAiB,EAAAC,EAAAmC,EAAAE,GACA,QACA,OAAAF,GAAA,IAAAE,EAAA,OAAAxD,EAAAC,EAAAiB,EAAAC,GACA,GAAAmC,EAAAE,EAAA,YACA,IAAAlK,EAAAC,EAAAlD,EAAAiN,GAAAE,EACA,EAAAnN,GAAAiD,EAAA0G,GAAAkB,EAAAlB,IAAA7G,KAAAyH,KAAAX,IAAAkB,EAAAlB,GAAA1G,EAAAJ,KAAAyH,MACA,EAAAvK,GAAAiD,EAAA0G,GAAAkB,EAAAlB,IAAA7G,KAAAuH,KAAAT,IAAAkB,EAAAlB,GAAA1G,EAAAJ,KAAAuH,MACA,EAAArK,GAAAkD,EAAA0G,GAAAkB,EAAAlB,IAAA9G,KAAAwH,KAAAX,IAAAkB,EAAAlB,GAAA1G,EAAAH,KAAAwH,OACApH,EAAA0G,GAAAkB,EAAAlB,IAAA9G,KAAAsH,KAAAT,IAAAkB,EAAAlB,GAAA1G,EAAAH,KAAAsH,MACA6C,GAAAtD,EAAA1G,EAAA2G,EAAA1G,EAAA+J,EAAAnK,KAAAoK,YAAAvD,EAAAC,KACAiB,EAAA5H,EAAA6H,EAAA5H,EAAAiK,EAAArK,KAAAoK,YAAArC,EAAAC,KAGA/I,cAAApC,EAAAqC,EAAAqM,EAAAC,EAAAC,EAAAC,GACA,IAAA/M,EAAAoM,EAAAhI,MAAA4I,KAAAzM,GAGA,IAFAP,EAAAqB,KAAAwJ,SAAAuB,EAAA,GAAAA,EAAA,GAAAQ,EAAAC,KAAAT,EAAAa,QAAAjN,EAAA,GAAAA,EAAA,KACAA,EAAAqB,KAAAwJ,SAAAuB,IAAAxL,OAAA,GAAAwL,IAAAxL,OAAA,GAAAkM,EAAAC,KAAAX,EAAA7D,KAAAvI,EAAA,GAAAA,EAAA,IACAoM,EAAA/K,KAAA6K,YAAAhO,EAAAkO,GACA,QAAAZ,EAAA7H,EAAA,EAAAhE,EAAAyM,EAAAxL,OAAA8K,EAAArK,KAAAoL,UAAAL,EAAAzM,EAAA,GAAAyM,EAAAzM,EAAA,IAAgFgE,EAAAhE,EAAOgE,GAAA,EACvF6H,EAAAE,IAAArK,KAAAoL,UAAAL,EAAAzI,GAAAyI,EAAAzI,EAAA,IACA6H,GAAAE,IAAA/H,EAAAtC,KAAAqL,MAAAxO,EAAAsN,EAAAE,EAAAU,EAAAzI,GAAAhE,EAAAyM,EAAAxL,aAEKS,KAAAsL,SAAAzO,GAAAmD,KAAAsH,KAAAtH,KAAAwH,MAAA,GAAAxH,KAAAuH,KAAAvH,KAAAyH,MAAA,KACLsD,GAAA/K,KAAAsH,KAAAtH,KAAAuH,KAAAvH,KAAAwH,KAAAxH,KAAAuH,KAAAvH,KAAAwH,KAAAxH,KAAAyH,KAAAzH,KAAAsH,KAAAtH,KAAAyH,OAEA,OAAAsD,EAEA9L,MAAApC,EAAA4N,EAAAK,EAAAC,EAAAzI,GACA,KAAAmI,IAAAK,GAAA,CACA,IAAA3K,EAAAC,EACA,OAAAqK,GACA,OAAAA,EAAA,EAAiC,SACjC,OAAAA,EAAA,EAAAtK,EAAAH,KAAAwH,KAAApH,EAAAJ,KAAAuH,KAA+D,MAC/D,OAAAkD,EAAA,EAAiC,SACjC,OAAAA,EAAA,GAAAtK,EAAAH,KAAAwH,KAAApH,EAAAJ,KAAAyH,KAA+D,MAC/D,QAAAgD,EAAA,EAAiC,SACjC,OAAAA,EAAA,EAAAtK,EAAAH,KAAAsH,KAAAlH,EAAAJ,KAAAyH,KAA+D,MAC/D,OAAAgD,EAAA,EAAiC,SACjC,OAAAA,EAAA,EAAAtK,EAAAH,KAAAsH,KAAAlH,EAAAJ,KAAAuH,KAEAwD,EAAAzI,KAAAnC,GAAA4K,EAAAzI,EAAA,KAAAlC,IAAAJ,KAAAsL,SAAAzO,EAAAsD,EAAAC,KACA2K,EAAAc,OAAAvJ,EAAA,EAAAnC,EAAAC,GAAAkC,GAAA,GAGA,OAAAA,EAEArD,SAAA4H,EAAAC,EAAAgF,EAAAC,GACA,IAAA7O,EAAAiD,EAAAC,EAAArC,EAAA4B,IACA,GAAAoM,EAAA,GACA,GAAAjF,GAAA9G,KAAAuH,KAAA,aACArK,GAAA8C,KAAAuH,KAAAT,GAAAiF,GAAAhO,IAAAqC,EAAAJ,KAAAuH,KAAApH,EAAA0G,GAAA9I,EAAAb,GAAA4O,QACK,GAAAC,EAAA,GACL,GAAAjF,GAAA9G,KAAAyH,KAAA,aACAvK,GAAA8C,KAAAyH,KAAAX,GAAAiF,GAAAhO,IAAAqC,EAAAJ,KAAAyH,KAAAtH,EAAA0G,GAAA9I,EAAAb,GAAA4O,GAEA,GAAAA,EAAA,GACA,GAAAjF,GAAA7G,KAAAwH,KAAA,aACAtK,GAAA8C,KAAAwH,KAAAX,GAAAiF,GAAA/N,IAAAoC,EAAAH,KAAAwH,KAAApH,EAAA0G,GAAA/I,EAAAb,GAAA6O,QACK,GAAAD,EAAA,GACL,GAAAjF,GAAA7G,KAAAsH,KAAA,aACApK,GAAA8C,KAAAsH,KAAAT,GAAAiF,GAAA/N,IAAAoC,EAAAH,KAAAsH,KAAAlH,EAAA0G,GAAA/I,EAAAb,GAAA6O,GAEA,OAAA5L,EAAAC,GAEAnB,UAAAkB,EAAAC,GACA,OAAAD,IAAAH,KAAAsH,KAAA,EACAnH,IAAAH,KAAAwH,KAAA,MACApH,IAAAJ,KAAAuH,KAAA,EACAnH,IAAAJ,KAAAyH,KAAA,KAEAxI,YAAAkB,EAAAC,GACA,OAAAD,EAAAH,KAAAsH,KAAA,EACAnH,EAAAH,KAAAwH,KAAA,MACApH,EAAAJ,KAAAuH,KAAA,EACAnH,EAAAJ,KAAAyH,KAAA,MCzPA,MAAAuE,EAAA,EAAAlN,KAAAmN,SAUqBC,EACrBjN,YAAAC,GACA,MAAAoE,UAAWA,EAAAL,OAAAI,aAA2B,IAAOrE,EAAUE,GACvDc,KAAAd,SACAc,KAAAsD,YACAtD,KAAAiD,OACAjD,KAAAqD,YACA,MAAAmH,EAAAxK,KAAAwK,QAAA,IAAAjH,WAAArE,EAAAK,OAAA,GAAA4M,MAAA,GACAC,EAAApM,KAAAoM,SAAA,IAAA7I,WAAArE,EAAAK,OAAA,GAAA4M,MAAA,GAGA,QAAAnJ,EAAA,EAAA1E,EAAAgF,EAAA/D,OAAyCyD,EAAA1E,IAAO0E,EAChDwH,EAAAnH,EAAAL,EAAA,KAAAA,EAAA,EAAAA,EAAA,IAAAA,EAIA,IAAAqJ,EAAAC,EAAArJ,EACA,GACAoJ,EAAAC,EACA9B,GADA8B,IAAAnI,MACAtH,GAAAwP,EAAAtO,EACAqO,EAAAC,EAAAxP,GAAAyP,EAAAvO,QACKuO,IAAArJ,GAELhE,QAAAsN,GACA,WAAenF,EAAOpH,KAAAuM,GAEtBtN,WAAApC,GACA,MAAA2N,QAAWA,EAAA4B,WAAA9I,YAAAD,aAAwCrD,KACnDyK,EAAAD,EAAA3N,GACA,QAAA4N,EAAA,OACA,IAAAzH,EAAAyH,EACA,GAGA,SAFApH,EAAAL,GAEAK,EADAL,IAAA,KAAAA,EAAA,EAAAA,EAAA,KACAnG,EAAA,OAEA,SADAmG,EAAAM,EAAAN,IACA,aAAAK,EAAA+I,EAAAvP,UACKmG,IAAAyH,GAELxL,KAAAkB,EAAAC,EAAAvD,EAAA,GACA,IAAAsD,WAAAC,SAAA,SACA,IAAAlD,EACA,MAAAA,EAAA8C,KAAAuK,MAAA1N,EAAAsD,EAAAC,KAAA,GAAAlD,IAAAL,KAAAK,EACA,OAAAA,EAEA+B,MAAApC,EAAAsD,EAAAC,GACA,MAAAoK,QAAWA,EAAAtL,UAAgBc,KAC3B,QAAAwK,EAAA3N,GAAA,SACA,IAAAK,EAAAL,EACA2P,GAAArM,EAAAjB,EAAA,EAAArC,KAAA,GAAAuD,EAAAlB,EAAA,EAAArC,EAAA,OACA,UAAAkB,KAAAiC,KAAAyM,UAAA5P,GAAA,CACA,MAAA6P,GAAAvM,EAAAjB,EAAA,EAAAnB,KAAA,GAAAqC,EAAAlB,EAAA,EAAAnB,EAAA,OACA2O,EAAAF,MAAAE,EAAAxP,EAAAa,GAEA,OAAAb,EAEA+B,OAAA4J,GACA,MAAAC,EAAA,MAAAD,IAAA,IAAmDtC,OAAIwC,GACvD7J,OAAWA,EAAAoE,YAAAD,aAA6BrD,KACxC,QAAAnD,EAAA,EAAAyB,EAAAgF,EAAA/D,OAAyC1C,EAAAyB,IAAOzB,EAAA,CAChD,MAAAyF,EAAAgB,EAAAzG,GACA,GAAAyF,EAAAzF,EAAA,SACA,MAAAmM,EAAA,EAAA3F,EAAAxG,GACAoM,EAAA,EAAA5F,EAAAf,GACAuG,EAAAc,OAAAzK,EAAA8J,GAAA9J,EAAA8J,EAAA,IACAH,EAAAe,OAAA1K,EAAA+J,GAAA/J,EAAA+J,EAAA,IAGA,OADAjJ,KAAA2M,WAAA9D,GACAC,KAAAhL,QAEAmB,aAAA4J,EAAAlL,EAAA,GACA,MAAAmL,EAAA,MAAAD,IAAA,IAAmDtC,OAAIwC,GACvD7J,OAAWA,GAAOc,KAClB,QAAAnD,EAAA,EAAAyB,EAAAY,EAAAK,OAAsC1C,EAAAyB,EAAOzB,GAAA,GAC7C,MAAAsD,EAAAjB,EAAArC,GAAAuD,EAAAlB,EAAArC,EAAA,GACAgM,EAAAc,OAAAxJ,EAAAxC,EAAAyC,GACAyI,EAAA+D,IAAAzM,EAAAC,EAAAzC,EAAA,EAAAqO,GAEA,OAAAlD,KAAAhL,QAEAmB,WAAA4J,GACA,MAAAC,EAAA,MAAAD,IAAA,IAAmDtC,OAAIwC,GACvD9F,KAAWA,GAAKjD,KAChB,IAAAmG,EAAAlD,EAEA,IADA4F,EAAAc,OAAAxD,EAAAhG,EAAAgG,EAAA/F,IACA+F,IAAAhC,QAAAlB,GAAA4F,EAAAe,OAAAzD,EAAAhG,EAAAgG,EAAA/F,GAEA,OADAyI,EAAAgB,YACAf,KAAAhL,QAEAmB,cACA,MAAA+K,EAAA,IAAwB/C,EAExB,OADAjH,KAAA2M,WAAA3C,GACAA,EAAAlM,QAEAmB,eAAApC,EAAAgM,GACA,MAAAC,EAAA,MAAAD,IAAA,IAAmDtC,OAAIwC,GACvD7J,OAAWA,EAAAmE,aAAkBrD,KAC7B6M,EAAA,EAAAxJ,EAAAxG,GAAA,GACA+K,EAAA,EAAAvE,EAAAxG,EAAA,GACAgL,EAAA,EAAAxE,EAAAxG,EAAA,GAKA,OAJAgM,EAAAc,OAAAzK,EAAA2N,GAAA3N,EAAA2N,EAAA,IACAhE,EAAAe,OAAA1K,EAAA0I,GAAA1I,EAAA0I,EAAA,IACAiB,EAAAe,OAAA1K,EAAA2I,GAAA3I,EAAA2I,EAAA,IACAgB,EAAAgB,YACAf,KAAAhL,QAEAmB,oBACA,MAAAoE,UAAWA,GAAUrD,KACrB,QAAAnD,EAAA,EAAAyB,EAAA+E,EAAA9D,OAAA,EAA6C1C,EAAAyB,IAAOzB,QACpDmD,KAAA8M,gBAAAjQ,GAGAoC,gBAAApC,GACA,MAAAmN,EAAA,IAAwB/C,EAExB,OADAjH,KAAA+M,eAAAlQ,EAAAmN,GACAA,EAAAlM,s5BAIAoO,EAAQP,KAAA,SAAAzM,EAAAqG,EA/HR,SAAA5G,GACA,OAAAA,EAAA,IA8HQ6G,EA3HR,SAAA7G,GACA,OAAAA,EAAA,IA0HQqO,GACR,WAAad,EAAQ,WAAAhN,EAKrB,SAAAA,EAAAqG,EAAAC,EAAAwH,GACA,MAAA1O,EAAAY,EAAAK,OACA0N,EAAA,IAAAxN,aAAA,EAAAnB,GACA,QAAAzB,EAAA,EAAiBA,EAAAyB,IAAOzB,EAAA,CACxB,MAAA8B,EAAAO,EAAArC,GACAoQ,EAAA,EAAApQ,GAAA0I,EAAAvI,KAAAgQ,EAAArO,EAAA9B,EAAAqC,GACA+N,EAAA,EAAApQ,EAAA,GAAA2I,EAAAxI,KAAAgQ,EAAArO,EAAA9B,EAAAqC,GAEA,OAAA+N,EAZAC,CAAAhO,EAAAqG,EAAAC,EAAAwH,GACAvN,aAAAkM,KAcA,UAAAzM,EAAAqG,EAAAC,EAAAwH,GACA,IAAAnQ,EAAA,EACA,UAAA8B,KAAAO,QACAqG,EAAAvI,KAAAgQ,EAAArO,EAAA9B,EAAAqC,SACAsG,EAAAxI,KAAAgQ,EAAArO,EAAA9B,EAAAqC,KACArC,EAnBAsQ,CAAAjO,EAAAqG,EAAAC,EAAAwH,UCvIMI,aACJ,SAAAA,EAAYvQ,EAAGwQ,GAAS,IAAAC,EAAAtN,kGAAAuN,CAAAvN,KAAAoN,GACtBpN,KAAKwN,GAAK3Q,EACVmD,KAAKgK,QAAUqD,EAAQtD,YAAYlN,GACnCmD,KAAKyN,KAAO,IAAIC,OAAOL,EAAQpD,WAAWpN,IAC1CmD,KAAKqN,QAAUA,EACfrN,KAAKmM,MACHwB,IAAO,EACPC,MAAS,IACTC,KAAQ,IACRC,MAAS,GAEX9N,KAAK+N,QACHJ,IAAO,EACPC,MAAS,IACTC,KAAQ,IACRC,MAAS,GAEX9N,KAAKyM,UAAYuB,EAAIX,EAAQhG,SAASoF,UAAUzM,KAAKwN,KAAKS,OAAO,SAAAnE,GAAI,OAAIwD,EAAKY,QAAQpE,4FAGhFA,GAAM,IACR0D,EADQW,EAAAnO,KAGZ,OAD4BwN,EAAxB1D,aAAgBsD,EAAatD,EAAK0D,GAAiB1D,EAChD9J,KAAKgK,QAAQoE,KAAK,SAAAC,GAAA,IAAAC,EAAAC,EAAAF,EAAA,GAAElO,EAAFmO,EAAA,GAAKlO,EAALkO,EAAA,UAAYH,EAAKd,QAAQtD,YAAYyD,GAAIY,KAAK,SAAAI,GAAA,IAAAC,EAAAF,EAAAC,EAAA,GAAEE,EAAFD,EAAA,GAAME,EAANF,EAAA,UAActO,GAAKuO,GAAMtO,GAAKuO,eAIzGC,SAASC,iBAAiB,mBAAoB,WAC5C,IAAMC,EAAWF,SAASG,eAAe,UACnCC,EAAMF,EAASG,WAAW,MAEhCH,EAASI,MAAQC,KAAKC,WACtBN,EAASO,OAASF,KAAKG,YAMvB,IAJA,IAAIpQ,KAEEqQ,EAAYrQ,EAAOK,OAAUuP,EAASI,MAAQJ,EAASO,OAAS,KAE7DxS,EAAIqC,EAAOK,OAAQ1C,EAAI0S,EAAW1S,IACzCqC,EAAOgI,MACLpI,KAAK2F,MAAMqK,EAASI,MAAQpQ,KAAK0Q,UACjC1Q,KAAK2F,MAAMqK,EAASO,OAASvQ,KAAK0Q,YAItC,IACMnC,EADWoC,EAAS9D,KAAKzM,GACNmO,SAAS,EAAG,EAAGyB,EAASI,MAAOJ,EAASO,SAG/DhC,EAAQqC,OAAOV,GACfA,EAAIW,UAAY,yBAChBX,EAAIY,SAAS,EAAG,EAAGd,EAASI,MAAOJ,EAASO,QAC5CL,EAAIa,QAAU,QACdb,EAAIc,YAAc,yBAClBd,EAAIe,UAAY,EAChBf,EAAIgB,SAON,IAFA,IAAMC,KAEGpT,EAAI,EAAGA,EAAI0S,EAAW1S,IAC7BoT,EAAS/I,KAAK,IAAIkG,EAAKvQ,EAAGwQ,IAW5B,SAAS6C,EAASpG,GAChBkF,EAAIW,UAAJ,QAAAQ,OAAwBrG,EAAKqC,KAAKwB,IAAlC,MAAAwC,OAA0CrG,EAAKqC,KAAKyB,MAApD,MAAAuC,OAA8DrG,EAAKqC,KAAK0B,KAAxE,MAAAsC,OAAiFrG,EAAKqC,KAAK2B,MAA3F,KACAkB,EAAIc,YAAJ,QAAAK,OAA0BrG,EAAKiE,OAAOJ,IAAtC,MAAAwC,OAA8CrG,EAAKiE,OAAOH,MAA1D,MAAAuC,OAAoErG,EAAKiE,OAAOF,KAAhF,MAAAsC,OAAyFrG,EAAKiE,OAAOD,MAArG,KACAkB,EAAI7C,KAAKrC,EAAK2D,MACduB,EAAIgB,OAAOlG,EAAK2D,MAoBlB,SAAS2C,EAActG,EAAMuG,EAAWC,GACtCtB,EAAIW,UAAJ,QAAAQ,OAAwBE,EAAU1C,IAAlC,MAAAwC,OAA0CE,EAAUzC,MAApD,MAAAuC,OAA8DE,EAAUxC,KAAxE,MAAAsC,OAAiFE,EAAUvC,MAA3F,KACAkB,EAAIc,YAAJ,QAAAK,OAA0BG,EAAY3C,IAAtC,MAAAwC,OAA8CG,EAAY1C,MAA1D,MAAAuC,OAAoEG,EAAYzC,KAAhF,MAAAsC,OAAyFG,EAAYxC,MAArG,KACAkB,EAAI7C,KAAKrC,EAAK2D,MACduB,EAAIgB,OAAOlG,EAAK2D,MASlB,IAAI8C,EAAgBN,EAAS,GACzBO,EAAmBP,EAAS,GAC5BQ,GAAW,EACXC,EAAc,EAElB5B,EAASD,iBAAiB,YAAa,SAAC7L,GACtC,IAAI2N,EAnDN,SAAqB7B,EAAU9L,GAC7B,IAAIyG,EAAOqF,EAAS8B,wBACpB,OACEzQ,EAAG6C,EAAE6N,QAAUpH,EAAKrH,KACpBhC,EAAG4C,EAAE8N,QAAUrH,EAAKsH,KA+CPC,CAAYlC,EAAU9L,GACrC,IAAKqK,EAAQ/B,SAASkF,EAAiBhD,GAAImD,EAASxQ,EAAGwQ,EAASvQ,GAC9D,QAAA6Q,EAAA,EAAAA,EAAiBhB,EAAjB1Q,OAAA0R,IAA2B,CAAtB,IAAInH,EAAQmG,EAAJgB,GACP5D,EAAQ/B,SAASxB,EAAK0D,GAAImD,EAASxQ,EAAGwQ,EAASvQ,KACjDmQ,EAAgBC,EAChBA,EAAmB1G,GAKrB0G,GAAoBD,GACtBH,EAAcI,EAAkBA,EAAiBrE,MAAQwB,IAAK,IAAKC,MAAO,IAAKC,KAAM,IAAKC,MAAO,MAElG,GAEHgB,EAASD,iBAAiB,YAAa,SAACqC,GACtCA,EAAMC,iBACNT,EAAcQ,EAAME,OACpBX,GAAW,IACV,GAEH3B,EAASD,iBAAiB,cAAe,SAACqC,GACxCA,EAAMC,iBACNT,EAAcQ,EAAME,OACpBX,GAAW,IACV,GAEH3B,EAASD,iBAAiB,UAAW,WACnC4B,GAAW,IACV,GAEH3B,EAASD,iBAAiB,WAAY,WACpC4B,GAAW,IACV,GAEHY,OAAOC,YAAY,WAEjB,IADA,IAAIC,KACJC,EAAA,EAAAA,EAAiBvB,EAAjB1Q,OAAAiS,IAA2B,CAAtB,IAAI1H,EAAQmG,EAAJuB,GACXD,EAAUrK,KAAK4C,EAAK2C,UAAUgF,OAAO,SAACC,EAAKC,GACzC,OAAOD,EAAMzB,EAAS0B,GAAUxF,KAAKwB,KACpC,GAAK7D,EAAK2C,UAAUlN,QAEzB,IAAK,IAAI1C,EAAI,EAAGA,EAAI0U,EAAUhS,OAAQ1C,IAChCoT,EAASpT,IAAM2T,IACbP,EAASpT,GAAGsP,KAAKwB,IAAM4D,EAAU1U,GACnCoT,EAASpT,GAAGsP,KAAKwB,KAAO,EACfsC,EAASpT,GAAGsP,KAAKwB,IAAM4D,EAAU1U,KAC1CoT,EAASpT,GAAGsP,KAAKwB,KAAO,GAE1BuC,EAASD,EAASpT,KAIlB4T,IACiB,GAAfC,EAAoBF,EAAiBrE,KAAKwB,KAAO,EAA4B,GAAf+C,IAAoBF,EAAiBrE,KAAKwB,KAAO,GACnHuC,EAASM,IAGXJ,EAAcI,EAAkBA,EAAiBrE,MAAQwB,IAAK,IAAKC,MAAO,IAAKC,KAAM,IAAKC,MAAO,KAChG","file":"./bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","\nconst EPSILON = Math.pow(2, -52);\n\nexport default class Delaunator {\n\n    static from(points, getX, getY) {\n        if (!getX) getX = defaultGetX;\n        if (!getY) getY = defaultGetY;\n\n        const n = points.length;\n        const coords = new Float64Array(n * 2);\n\n        for (let i = 0; i < n; i++) {\n            const p = points[i];\n            coords[2 * i] = getX(p);\n            coords[2 * i + 1] = getY(p);\n        }\n\n        return new Delaunator(coords);\n    }\n\n    constructor(coords) {\n        let minX = Infinity;\n        let minY = Infinity;\n        let maxX = -Infinity;\n        let maxY = -Infinity;\n\n        const n = coords.length >> 1;\n        const ids = this.ids = new Uint32Array(n);\n\n        if (n > 0 && typeof coords[0] !== 'number') throw new Error('Expected coords to contain numbers.');\n\n        this.coords = coords;\n\n        for (let i = 0; i < n; i++) {\n            const x = coords[2 * i];\n            const y = coords[2 * i + 1];\n            if (x < minX) minX = x;\n            if (y < minY) minY = y;\n            if (x > maxX) maxX = x;\n            if (y > maxY) maxY = y;\n            ids[i] = i;\n        }\n\n        const cx = (minX + maxX) / 2;\n        const cy = (minY + maxY) / 2;\n\n        let minDist = Infinity;\n        let i0, i1, i2;\n\n        // pick a seed point close to the centroid\n        for (let i = 0; i < n; i++) {\n            const d = dist(cx, cy, coords[2 * i], coords[2 * i + 1]);\n            if (d < minDist) {\n                i0 = i;\n                minDist = d;\n            }\n        }\n        const i0x = coords[2 * i0];\n        const i0y = coords[2 * i0 + 1];\n\n        minDist = Infinity;\n\n        // find the point closest to the seed\n        for (let i = 0; i < n; i++) {\n            if (i === i0) continue;\n            const d = dist(i0x, i0y, coords[2 * i], coords[2 * i + 1]);\n            if (d < minDist && d > 0) {\n                i1 = i;\n                minDist = d;\n            }\n        }\n        let i1x = coords[2 * i1];\n        let i1y = coords[2 * i1 + 1];\n\n        let minRadius = Infinity;\n\n        // find the third point which forms the smallest circumcircle with the first two\n        for (let i = 0; i < n; i++) {\n            if (i === i0 || i === i1) continue;\n            const r = circumradius(i0x, i0y, i1x, i1y, coords[2 * i], coords[2 * i + 1]);\n            if (r < minRadius) {\n                i2 = i;\n                minRadius = r;\n            }\n        }\n        let i2x = coords[2 * i2];\n        let i2y = coords[2 * i2 + 1];\n\n        if (minRadius === Infinity) {\n            throw new Error('No Delaunay triangulation exists for this input.');\n        }\n\n        // swap the order of the seed points for counter-clockwise orientation\n        if (orient(i0x, i0y, i1x, i1y, i2x, i2y)) {\n            const i = i1;\n            const x = i1x;\n            const y = i1y;\n            i1 = i2;\n            i1x = i2x;\n            i1y = i2y;\n            i2 = i;\n            i2x = x;\n            i2y = y;\n        }\n\n        const center = circumcenter(i0x, i0y, i1x, i1y, i2x, i2y);\n        this._cx = center.x;\n        this._cy = center.y;\n\n        // sort the points by distance from the seed triangle circumcenter\n        quicksort(ids, coords, 0, ids.length - 1, center.x, center.y);\n\n        // initialize a hash table for storing edges of the advancing convex hull\n        this._hashSize = Math.ceil(Math.sqrt(n));\n        this._hash = new Array(this._hashSize);\n\n        // initialize a circular doubly-linked list that will hold an advancing convex hull\n        let e = this.hull = insertNode(coords, i0);\n        this._hashEdge(e);\n        e.t = 0;\n        e = insertNode(coords, i1, e);\n        this._hashEdge(e);\n        e.t = 1;\n        e = insertNode(coords, i2, e);\n        this._hashEdge(e);\n        e.t = 2;\n\n        const maxTriangles = 2 * n - 5;\n        const triangles = this.triangles = new Uint32Array(maxTriangles * 3);\n        const halfedges = this.halfedges = new Int32Array(maxTriangles * 3);\n\n        this.trianglesLen = 0;\n\n        this._addTriangle(i0, i1, i2, -1, -1, -1);\n\n        for (let k = 0, xp, yp; k < ids.length; k++) {\n            const i = ids[k];\n            const x = coords[2 * i];\n            const y = coords[2 * i + 1];\n\n            // skip near-duplicate points\n            if (k > 0 && Math.abs(x - xp) <= EPSILON && Math.abs(y - yp) <= EPSILON) continue;\n            xp = x;\n            yp = y;\n\n            // skip seed triangle points\n            if (i === i0 || i === i1 || i === i2) continue;\n\n            // find a visible edge on the convex hull using edge hash\n            const startKey = this._hashKey(x, y);\n            let key = startKey;\n            let start;\n            do {\n                start = this._hash[key];\n                key = (key + 1) % this._hashSize;\n            } while ((!start || start.removed) && key !== startKey);\n\n            start = start.prev;\n            e = start;\n            while (!orient(x, y, e.x, e.y, e.next.x, e.next.y)) {\n                e = e.next;\n                if (e === start) {\n                    e = null;\n                    break;\n                }\n            }\n            // likely a near-duplicate point; skip it\n            if (!e) continue;\n\n            const walkBack = e === start;\n\n            // add the first triangle from the point\n            let t = this._addTriangle(e.i, i, e.next.i, -1, -1, e.t);\n\n            e.t = t; // keep track of boundary triangles on the hull\n            e = insertNode(coords, i, e);\n\n            // recursively flip triangles from the point until they satisfy the Delaunay condition\n            e.t = this._legalize(t + 2);\n\n            // walk forward through the hull, adding more triangles and flipping recursively\n            let q = e.next;\n            while (orient(x, y, q.x, q.y, q.next.x, q.next.y)) {\n                t = this._addTriangle(q.i, i, q.next.i, q.prev.t, -1, q.t);\n                q.prev.t = this._legalize(t + 2);\n                this.hull = removeNode(q);\n                q = q.next;\n            }\n\n            if (walkBack) {\n                // walk backward from the other side, adding more triangles and flipping\n                q = e.prev;\n                while (orient(x, y, q.prev.x, q.prev.y, q.x, q.y)) {\n                    t = this._addTriangle(q.prev.i, i, q.i, -1, q.t, q.prev.t);\n                    this._legalize(t + 2);\n                    q.prev.t = t;\n                    this.hull = removeNode(q);\n                    q = q.prev;\n                }\n            }\n\n            // save the two new edges in the hash table\n            this._hashEdge(e);\n            this._hashEdge(e.prev);\n        }\n\n        // trim typed triangle mesh arrays\n        this.triangles = triangles.subarray(0, this.trianglesLen);\n        this.halfedges = halfedges.subarray(0, this.trianglesLen);\n    }\n\n    _hashEdge(e) {\n        this._hash[this._hashKey(e.x, e.y)] = e;\n    }\n\n    _hashKey(x, y) {\n        return Math.floor(pseudoAngle(x - this._cx, y - this._cy) * this._hashSize) % this._hashSize;\n    }\n\n    _legalize(a) {\n        const {triangles, coords, halfedges} = this;\n\n        const b = halfedges[a];\n\n        /* if the pair of triangles doesn't satisfy the Delaunay condition\n         * (p1 is inside the circumcircle of [p0, pl, pr]), flip them,\n         * then do the same check/flip recursively for the new pair of triangles\n         *\n         *           pl                    pl\n         *          /||\\                  /  \\\n         *       al/ || \\bl            al/    \\a\n         *        /  ||  \\              /      \\\n         *       /  a||b  \\    flip    /___ar___\\\n         *     p0\\   ||   /p1   =>   p0\\---bl---/p1\n         *        \\  ||  /              \\      /\n         *       ar\\ || /br             b\\    /br\n         *          \\||/                  \\  /\n         *           pr                    pr\n         */\n        const a0 = a - a % 3;\n        const b0 = b - b % 3;\n\n        const al = a0 + (a + 1) % 3;\n        const ar = a0 + (a + 2) % 3;\n        const bl = b0 + (b + 2) % 3;\n\n        if (b === -1) return ar;\n\n        const p0 = triangles[ar];\n        const pr = triangles[a];\n        const pl = triangles[al];\n        const p1 = triangles[bl];\n\n        const illegal = inCircle(\n            coords[2 * p0], coords[2 * p0 + 1],\n            coords[2 * pr], coords[2 * pr + 1],\n            coords[2 * pl], coords[2 * pl + 1],\n            coords[2 * p1], coords[2 * p1 + 1]);\n\n        if (illegal) {\n            triangles[a] = p1;\n            triangles[b] = p0;\n\n            const hbl = halfedges[bl];\n\n            // edge swapped on the other side of the hull (rare); fix the halfedge reference\n            if (hbl === -1) {\n                let e = this.hull;\n                do {\n                    if (e.t === bl) {\n                        e.t = a;\n                        break;\n                    }\n                    e = e.next;\n                } while (e !== this.hull);\n            }\n            this._link(a, hbl);\n            this._link(b, halfedges[ar]);\n            this._link(ar, bl);\n\n            const br = b0 + (b + 1) % 3;\n\n            this._legalize(a);\n            return this._legalize(br);\n        }\n\n        return ar;\n    }\n\n    _link(a, b) {\n        this.halfedges[a] = b;\n        if (b !== -1) this.halfedges[b] = a;\n    }\n\n    // add a new triangle given vertex indices and adjacent half-edge ids\n    _addTriangle(i0, i1, i2, a, b, c) {\n        const t = this.trianglesLen;\n\n        this.triangles[t] = i0;\n        this.triangles[t + 1] = i1;\n        this.triangles[t + 2] = i2;\n\n        this._link(t, a);\n        this._link(t + 1, b);\n        this._link(t + 2, c);\n\n        this.trianglesLen += 3;\n\n        return t;\n    }\n}\n\n// monotonically increases with real angle, but doesn't need expensive trigonometry\nfunction pseudoAngle(dx, dy) {\n    const p = dx / (Math.abs(dx) + Math.abs(dy));\n    return (dy > 0 ? 3 - p : 1 + p) / 4; // [0..1]\n}\n\nfunction dist(ax, ay, bx, by) {\n    const dx = ax - bx;\n    const dy = ay - by;\n    return dx * dx + dy * dy;\n}\n\nfunction orient(px, py, qx, qy, rx, ry) {\n    return (qy - py) * (rx - qx) - (qx - px) * (ry - qy) < 0;\n}\n\nfunction inCircle(ax, ay, bx, by, cx, cy, px, py) {\n    const dx = ax - px;\n    const dy = ay - py;\n    const ex = bx - px;\n    const ey = by - py;\n    const fx = cx - px;\n    const fy = cy - py;\n\n    const ap = dx * dx + dy * dy;\n    const bp = ex * ex + ey * ey;\n    const cp = fx * fx + fy * fy;\n\n    return dx * (ey * cp - bp * fy) -\n           dy * (ex * cp - bp * fx) +\n           ap * (ex * fy - ey * fx) < 0;\n}\n\nfunction circumradius(ax, ay, bx, by, cx, cy) {\n    const dx = bx - ax;\n    const dy = by - ay;\n    const ex = cx - ax;\n    const ey = cy - ay;\n\n    const bl = dx * dx + dy * dy;\n    const cl = ex * ex + ey * ey;\n    const d = dx * ey - dy * ex;\n\n    const x = (ey * bl - dy * cl) * 0.5 / d;\n    const y = (dx * cl - ex * bl) * 0.5 / d;\n\n    return bl && cl && d && (x * x + y * y) || Infinity;\n}\n\nfunction circumcenter(ax, ay, bx, by, cx, cy) {\n    const dx = bx - ax;\n    const dy = by - ay;\n    const ex = cx - ax;\n    const ey = cy - ay;\n\n    const bl = dx * dx + dy * dy;\n    const cl = ex * ex + ey * ey;\n    const d = dx * ey - dy * ex;\n\n    const x = ax + (ey * bl - dy * cl) * 0.5 / d;\n    const y = ay + (dx * cl - ex * bl) * 0.5 / d;\n\n    return {x, y};\n}\n\n// create a new node in a doubly linked list\nfunction insertNode(coords, i, prev) {\n    const node = {\n        i,\n        x: coords[2 * i],\n        y: coords[2 * i + 1],\n        t: 0,\n        prev: null,\n        next: null,\n        removed: false\n    };\n\n    if (!prev) {\n        node.prev = node;\n        node.next = node;\n\n    } else {\n        node.next = prev.next;\n        node.prev = prev;\n        prev.next.prev = node;\n        prev.next = node;\n    }\n    return node;\n}\n\nfunction removeNode(node) {\n    node.prev.next = node.next;\n    node.next.prev = node.prev;\n    node.removed = true;\n    return node.prev;\n}\n\nfunction quicksort(ids, coords, left, right, cx, cy) {\n    let i, j, temp;\n\n    if (right - left <= 20) {\n        for (i = left + 1; i <= right; i++) {\n            temp = ids[i];\n            j = i - 1;\n            while (j >= left && compare(coords, ids[j], temp, cx, cy) > 0) ids[j + 1] = ids[j--];\n            ids[j + 1] = temp;\n        }\n    } else {\n        const median = (left + right) >> 1;\n        i = left + 1;\n        j = right;\n        swap(ids, median, i);\n        if (compare(coords, ids[left], ids[right], cx, cy) > 0) swap(ids, left, right);\n        if (compare(coords, ids[i], ids[right], cx, cy) > 0) swap(ids, i, right);\n        if (compare(coords, ids[left], ids[i], cx, cy) > 0) swap(ids, left, i);\n\n        temp = ids[i];\n        while (true) {\n            do i++; while (compare(coords, ids[i], temp, cx, cy) < 0);\n            do j--; while (compare(coords, ids[j], temp, cx, cy) > 0);\n            if (j < i) break;\n            swap(ids, i, j);\n        }\n        ids[left + 1] = ids[j];\n        ids[j] = temp;\n\n        if (right - i + 1 >= j - left) {\n            quicksort(ids, coords, i, right, cx, cy);\n            quicksort(ids, coords, left, j - 1, cx, cy);\n        } else {\n            quicksort(ids, coords, left, j - 1, cx, cy);\n            quicksort(ids, coords, i, right, cx, cy);\n        }\n    }\n}\n\nfunction compare(coords, i, j, cx, cy) {\n    const d1 = dist(coords[2 * i], coords[2 * i + 1], cx, cy);\n    const d2 = dist(coords[2 * j], coords[2 * j + 1], cx, cy);\n    return (d1 - d2) || (coords[2 * i] - coords[2 * j]) || (coords[2 * i + 1] - coords[2 * j + 1]);\n}\n\nfunction swap(arr, i, j) {\n    const tmp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = tmp;\n}\n\nfunction defaultGetX(p) {\n    return p[0];\n}\nfunction defaultGetY(p) {\n    return p[1];\n}\n","const epsilon = 1e-6;\n\nexport default class Path {\n  constructor() {\n    this._x0 = this._y0 = // start of current subpath\n    this._x1 = this._y1 = null; // end of current subpath\n    this._ = \"\";\n  }\n  moveTo(x, y) {\n    this._ += `M${this._x0 = this._x1 = +x},${this._y0 = this._y1 = +y}`;\n  }\n  closePath() {\n    if (this._x1 !== null) {\n      this._x1 = this._x0, this._y1 = this._y0;\n      this._ += \"Z\";\n    }\n  }\n  lineTo(x, y) {\n    this._ += `L${this._x1 = +x},${this._y1 = +y}`;\n  }\n  arc(x, y, r) {\n    x = +x, y = +y, r = +r;\n    const x0 = x + r;\n    const y0 = y;\n    if (r < 0) throw new Error(\"negative radius\");\n    if (this._x1 === null) this._ += `M${x0},${y0}`;\n    else if (Math.abs(this._x1 - x0) > epsilon || Math.abs(this._y1 - y0) > epsilon) this._ += \"L\" + x0 + \",\" + y0;\n    if (!r) return;\n    this._ += `A${r},${r},0,1,1,${x - r},${y}A${r},${r},0,1,1,${this._x1 = x0},${this._y1 = y0}`;\n  }\n  rect(x, y, w, h) {\n    this._ += `M${this._x0 = this._x1 = +x},${this._y0 = this._y1 = +y}h${+w}v${+h}h${-w}Z`;\n  }\n  value() {\n    return this._ || null;\n  }\n}\n","export default class Polygon {\n  constructor() {\n    this._ = [];\n  }\n  moveTo(x, y) {\n    this._.push([x, y]);\n  }\n  closePath() {\n    this._.push(this._[0].slice());\n  }\n  lineTo(x, y) {\n    this._.push([x, y]);\n  }\n  value() {\n    return this._.length ? this._ : null;\n  }\n}\n","import Path from \"./path.js\";\nimport Polygon from \"./polygon.js\";\n\nexport default class Voronoi {\n  constructor(delaunay, [xmin, ymin, xmax, ymax] = [0, 0, 960, 500]) {\n    if (!((xmax = +xmax) >= (xmin = +xmin)) || !((ymax = +ymax) >= (ymin = +ymin))) throw new Error(\"invalid bounds\");\n    const {points, hull, triangles} = this.delaunay = delaunay;\n    const circumcenters = this.circumcenters = new Float64Array(triangles.length / 3 * 2);\n    const vectors = this.vectors = new Float64Array(points.length * 2);\n    this.xmax = xmax, this.xmin = xmin;\n    this.ymax = ymax, this.ymin = ymin;\n\n    // Compute circumcenters.\n    for (let i = 0, j = 0, n = triangles.length; i < n; i += 3, j += 2) {\n      const t1 = triangles[i] * 2;\n      const t2 = triangles[i + 1] * 2;\n      const t3 = triangles[i + 2] * 2;\n      const x1 = points[t1];\n      const y1 = points[t1 + 1];\n      const x2 = points[t2];\n      const y2 = points[t2 + 1];\n      const x3 = points[t3];\n      const y3 = points[t3 + 1];\n      const a2 = x1 - x2;\n      const a3 = x1 - x3;\n      const b2 = y1 - y2;\n      const b3 = y1 - y3;\n      const d1 = x1 * x1 + y1 * y1;\n      const d2 = d1 - x2 * x2 - y2 * y2;\n      const d3 = d1 - x3 * x3 - y3 * y3;\n      const ab = (a3 * b2 - a2 * b3) * 2;\n      circumcenters[j] = (b2 * d3 - b3 * d2) / ab;\n      circumcenters[j + 1] = (a3 * d2 - a2 * d3) / ab;\n    }\n\n    // Compute exterior cell rays.\n    let node = hull;\n    let p0, p1 = node.i * 4;\n    let x0, x1 = node.x;\n    let y0, y1 = node.y;\n    do {\n      node = node.next, p0 = p1, x0 = x1, y0 = y1, p1 = node.i * 4, x1 = node.x, y1 = node.y;\n      vectors[p0 + 2] = vectors[p1] = y0 - y1;\n      vectors[p0 + 3] = vectors[p1 + 1] = x1 - x0;\n    } while (node !== hull);\n  }\n  render(context) {\n    const buffer = context == null ? context = new Path : undefined;\n    const {delaunay: {halfedges, hull}, circumcenters, vectors} = this;\n    for (let i = 0, n = halfedges.length; i < n; ++i) {\n      const j = halfedges[i];\n      if (j < i) continue;\n      const ti = Math.floor(i / 3) * 2;\n      const tj = Math.floor(j / 3) * 2;\n      const xi = circumcenters[ti];\n      const yi = circumcenters[ti + 1];\n      const xj = circumcenters[tj];\n      const yj = circumcenters[tj + 1];\n      this._renderSegment(xi, yi, xj, yj, context);\n    }\n    let node = hull;\n    do {\n      node = node.next;\n      const t = Math.floor(node.t / 3) * 2;\n      const x = circumcenters[t];\n      const y = circumcenters[t + 1];\n      const v = node.i * 4;\n      const p = this._project(x, y, vectors[v + 2], vectors[v + 3]);\n      if (p) this._renderSegment(x, y, p[0], p[1], context);\n    } while (node !== hull);\n    return buffer && buffer.value();\n  }\n  renderBounds(context) {\n    const buffer = context == null ? context = new Path : undefined;\n    context.rect(this.xmin, this.ymin, this.xmax - this.xmin, this.ymax - this.ymin);\n    return buffer && buffer.value();\n  }\n  renderCell(i, context) {\n    const buffer = context == null ? context = new Path : undefined;\n    const points = this._clip(i);\n    if (points === null) return;\n    context.moveTo(points[0], points[1]);\n    for (let i = 2, n = points.length; i < n; i += 2) {\n      context.lineTo(points[i], points[i + 1]);\n    }\n    context.closePath();\n    return buffer && buffer.value();\n  }\n  *cellPolygons() {\n    const {delaunay: {points}} = this;\n    for (let i = 0, n = points.length / 2; i < n; ++i) {\n      const cell = this.cellPolygon(i);\n      if (cell) yield cell;\n    }\n  }\n  cellPolygon(i) {\n    const polygon = new Polygon;\n    this.renderCell(i, polygon);\n    return polygon.value();\n  }\n  _renderSegment(x0, y0, x1, y1, context) {\n    let S;\n    const c0 = this._regioncode(x0, y0);\n    const c1 = this._regioncode(x1, y1);\n    if (c0 === 0 && c1 === 0) {\n      context.moveTo(x0, y0);\n      context.lineTo(x1, y1);\n    } else if (S = this._clipSegment(x0, y0, x1, y1, c0, c1)) {\n      context.moveTo(S[0], S[1]);\n      context.lineTo(S[2], S[3]);\n    }\n  }\n  contains(i, x, y) {\n    if ((x = +x, x !== x) || (y = +y, y !== y)) return false;\n    return this.delaunay._step(i, x, y) === i;\n  }\n  _cell(i) {\n    const {circumcenters, delaunay: {inedges, halfedges, triangles}} = this;\n    const e0 = inedges[i];\n    if (e0 === -1) return null; // coincident point\n    const points = [];\n    let e = e0;\n    do {\n      const t = Math.floor(e / 3);\n      points.push(circumcenters[t * 2], circumcenters[t * 2 + 1]);\n      e = e % 3 === 2 ? e - 2 : e + 1;\n      if (triangles[e] !== i) break; // bad triangulation\n      e = halfedges[e];\n    } while (e !== e0 && e !== -1);\n    return points;\n  }\n  _clip(i) {\n    const points = this._cell(i);\n    if (points === null) return null;\n    const {vectors: V} = this;\n    const v = i * 4;\n    return V[v] || V[v + 1]\n        ? this._clipInfinite(i, points, V[v], V[v + 1], V[v + 2], V[v + 3])\n        : this._clipFinite(i, points);\n  }\n  _clipFinite(i, points) {\n    const n = points.length;\n    let P = null;\n    let x0, y0, x1 = points[n - 2], y1 = points[n - 1];\n    let c0, c1 = this._regioncode(x1, y1);\n    let e0, e1;\n    for (let j = 0; j < n; j += 2) {\n      x0 = x1, y0 = y1, x1 = points[j], y1 = points[j + 1];\n      c0 = c1, c1 = this._regioncode(x1, y1);\n      if (c0 === 0 && c1 === 0) {\n        e0 = e1, e1 = 0;\n        if (P) P.push(x1, y1);\n        else P = [x1, y1];\n      } else {\n        let S, sx0, sy0, sx1, sy1;\n        if (c0 === 0) {\n          if ((S = this._clipSegment(x0, y0, x1, y1, c0, c1)) === null) continue;\n          [sx0, sy0, sx1, sy1] = S;\n        } else {\n          if ((S = this._clipSegment(x1, y1, x0, y0, c1, c0)) === null) continue;\n          [sx1, sy1, sx0, sy0] = S;\n          e0 = e1, e1 = this._edgecode(sx0, sy0);\n          if (e0 && e1) this._edge(i, e0, e1, P, P.length);\n          if (P) P.push(sx0, sy0);\n          else P = [sx0, sy0];\n        }\n        e0 = e1, e1 = this._edgecode(sx1, sy1);\n        if (e0 && e1) this._edge(i, e0, e1, P, P.length);\n        if (P) P.push(sx1, sy1);\n        else P = [sx1, sy1];\n      }\n    }\n    if (P) {\n      e0 = e1, e1 = this._edgecode(P[0], P[1]);\n      if (e0 && e1) this._edge(i, e0, e1, P, P.length);\n    } else if (this.contains(i, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2)) {\n      return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];\n    }\n    return P;\n  }\n  _clipSegment(x0, y0, x1, y1, c0, c1) {\n    while (true) {\n      if (c0 === 0 && c1 === 0) return [x0, y0, x1, y1];\n      if (c0 & c1) return null;\n      let x, y, c = c0 || c1;\n      if (c & 0b1000) x = x0 + (x1 - x0) * (this.ymax - y0) / (y1 - y0), y = this.ymax;\n      else if (c & 0b0100) x = x0 + (x1 - x0) * (this.ymin - y0) / (y1 - y0), y = this.ymin;\n      else if (c & 0b0010) y = y0 + (y1 - y0) * (this.xmax - x0) / (x1 - x0), x = this.xmax;\n      else y = y0 + (y1 - y0) * (this.xmin - x0) / (x1 - x0), x = this.xmin;\n      if (c0) x0 = x, y0 = y, c0 = this._regioncode(x0, y0);\n      else x1 = x, y1 = y, c1 = this._regioncode(x1, y1);\n    }\n  }\n  _clipInfinite(i, points, vx0, vy0, vxn, vyn) {\n    let P = Array.from(points), p;\n    if (p = this._project(P[0], P[1], vx0, vy0)) P.unshift(p[0], p[1]);\n    if (p = this._project(P[P.length - 2], P[P.length - 1], vxn, vyn)) P.push(p[0], p[1]);\n    if (P = this._clipFinite(i, P)) {\n      for (let j = 0, n = P.length, c0, c1 = this._edgecode(P[n - 2], P[n - 1]); j < n; j += 2) {\n        c0 = c1, c1 = this._edgecode(P[j], P[j + 1]);\n        if (c0 && c1) j = this._edge(i, c0, c1, P, j), n = P.length;\n      }\n    } else if (this.contains(i, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2)) {\n      P = [this.xmin, this.ymin, this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax];\n    }\n    return P;\n  }\n  _edge(i, e0, e1, P, j) {\n    while (e0 !== e1) {\n      let x, y;\n      switch (e0) {\n        case 0b0101: e0 = 0b0100; continue; // top-left\n        case 0b0100: e0 = 0b0110, x = this.xmax, y = this.ymin; break; // top\n        case 0b0110: e0 = 0b0010; continue; // top-right\n        case 0b0010: e0 = 0b1010, x = this.xmax, y = this.ymax; break; // right\n        case 0b1010: e0 = 0b1000; continue; // bottom-right\n        case 0b1000: e0 = 0b1001, x = this.xmin, y = this.ymax; break; // bottom\n        case 0b1001: e0 = 0b0001; continue; // bottom-left\n        case 0b0001: e0 = 0b0101, x = this.xmin, y = this.ymin; break; // left\n      }\n      if ((P[j] !== x || P[j + 1] !== y) && this.contains(i, x, y)) {\n        P.splice(j, 0, x, y), j += 2;\n      }\n    }\n    return j;\n  }\n  _project(x0, y0, vx, vy) {\n    let t = Infinity, c, x, y;\n    if (vy < 0) { // top\n      if (y0 <= this.ymin) return null;\n      if ((c = (this.ymin - y0) / vy) < t) y = this.ymin, x = x0 + (t = c) * vx;\n    } else if (vy > 0) { // bottom\n      if (y0 >= this.ymax) return null;\n      if ((c = (this.ymax - y0) / vy) < t) y = this.ymax, x = x0 + (t = c) * vx;\n    }\n    if (vx > 0) { // right\n      if (x0 >= this.xmax) return null;\n      if ((c = (this.xmax - x0) / vx) < t) x = this.xmax, y = y0 + (t = c) * vy;\n    } else if (vx < 0) { // left\n      if (x0 <= this.xmin) return null;\n      if ((c = (this.xmin - x0) / vx) < t) x = this.xmin, y = y0 + (t = c) * vy;\n    }\n    return [x, y];\n  }\n  _edgecode(x, y) {\n    return (x === this.xmin ? 0b0001\n        : x === this.xmax ? 0b0010 : 0b0000)\n        | (y === this.ymin ? 0b0100\n        : y === this.ymax ? 0b1000 : 0b0000);\n  }\n  _regioncode(x, y) {\n    return (x < this.xmin ? 0b0001\n        : x > this.xmax ? 0b0010 : 0b0000)\n        | (y < this.ymin ? 0b0100\n        : y > this.ymax ? 0b1000 : 0b0000);\n  }\n}\n","import Delaunator from \"delaunator\";\nimport Path from \"./path.js\";\nimport Polygon from \"./polygon.js\";\nimport Voronoi from \"./voronoi.js\";\n\nconst tau = 2 * Math.PI;\n\nfunction pointX(p) {\n  return p[0];\n}\n\nfunction pointY(p) {\n  return p[1];\n}\n\nexport default class Delaunay {\n  constructor(points) {\n    const {halfedges, hull, triangles} = new Delaunator(points);\n    this.points = points;\n    this.halfedges = halfedges;\n    this.hull = hull;\n    this.triangles = triangles;\n    const inedges = this.inedges = new Int32Array(points.length / 2).fill(-1);\n    const outedges = this.outedges = new Int32Array(points.length / 2).fill(-1);\n\n    // Compute an index from each point to an (arbitrary) incoming halfedge.\n    for (let e = 0, n = halfedges.length; e < n; ++e) {\n      inedges[triangles[e % 3 === 2 ? e - 2 : e + 1]] = e;\n    }\n\n    // For points on the hull, index both the incoming and outgoing halfedges.\n    let node0, node1 = hull;\n    do {\n      node0 = node1, node1 = node1.next;\n      inedges[node1.i] = node0.t;\n      outedges[node0.i] = node1.t;\n    } while (node1 !== hull);\n  }\n  voronoi(bounds) {\n    return new Voronoi(this, bounds);\n  }\n  *neighbors(i) {\n    const {inedges, outedges, halfedges, triangles} = this;\n    const e0 = inedges[i];\n    if (e0 === -1) return; // coincident point\n    let e = e0;\n    do {\n      yield triangles[e];\n      e = e % 3 === 2 ? e - 2 : e + 1;\n      if (triangles[e] !== i) return; // bad triangulation\n      e = halfedges[e];\n      if (e === -1) return yield triangles[outedges[i]];\n    } while (e !== e0);\n  }\n  find(x, y, i = 0) {\n    if ((x = +x, x !== x) || (y = +y, y !== y)) return -1;\n    let c;\n    while ((c = this._step(i, x, y)) >= 0 && c !== i) i = c;\n    return c;\n  }\n  _step(i, x, y) {\n    const {inedges, points} = this;\n    if (inedges[i] === -1) return -1; // coincident point\n    let c = i;\n    let dc = (x - points[i * 2]) ** 2 + (y - points[i * 2 + 1]) ** 2;\n    for (const t of this.neighbors(i)) {\n      const dt = (x - points[t * 2]) ** 2 + (y - points[t * 2 + 1]) ** 2;\n      if (dt < dc) dc = dt, c = t;\n    }\n    return c;\n  }\n  render(context) {\n    const buffer = context == null ? context = new Path : undefined;\n    const {points, halfedges, triangles} = this;\n    for (let i = 0, n = halfedges.length; i < n; ++i) {\n      const j = halfedges[i];\n      if (j < i) continue;\n      const ti = triangles[i] * 2;\n      const tj = triangles[j] * 2;\n      context.moveTo(points[ti], points[ti + 1]);\n      context.lineTo(points[tj], points[tj + 1]);\n    }\n    this.renderHull(context);\n    return buffer && buffer.value();\n  }\n  renderPoints(context, r = 2) {\n    const buffer = context == null ? context = new Path : undefined;\n    const {points} = this;\n    for (let i = 0, n = points.length; i < n; i += 2) {\n      const x = points[i], y = points[i + 1];\n      context.moveTo(x + r, y);\n      context.arc(x, y, r, 0, tau);\n    }\n    return buffer && buffer.value();\n  }\n  renderHull(context) {\n    const buffer = context == null ? context = new Path : undefined;\n    const {hull} = this;\n    let node = hull;\n    context.moveTo(node.x, node.y);\n    while (node = node.next, node !== hull) context.lineTo(node.x, node.y);\n    context.closePath();\n    return buffer && buffer.value();\n  }\n  hullPolygon() {\n    const polygon = new Polygon;\n    this.renderHull(polygon);\n    return polygon.value();\n  }\n  renderTriangle(i, context) {\n    const buffer = context == null ? context = new Path : undefined;\n    const {points, triangles} = this;\n    const t0 = triangles[i *= 3] * 2;\n    const t1 = triangles[i + 1] * 2;\n    const t2 = triangles[i + 2] * 2;\n    context.moveTo(points[t0], points[t0 + 1]);\n    context.lineTo(points[t1], points[t1 + 1]);\n    context.lineTo(points[t2], points[t2 + 1]);\n    context.closePath();\n    return buffer && buffer.value();\n  }\n  *trianglePolygons() {\n    const {triangles} = this;\n    for (let i = 0, n = triangles.length / 3; i < n; ++i) {\n      yield this.trianglePolygon(i);\n    }\n  }\n  trianglePolygon(i) {\n    const polygon = new Polygon;\n    this.renderTriangle(i, polygon);\n    return polygon.value();\n  }\n}\n\nDelaunay.from = function(points, fx = pointX, fy = pointY, that) {\n  return new Delaunay(\"length\" in points\n      ? flatArray(points, fx, fy, that)\n      : Float64Array.from(flatIterable(points, fx, fy, that)));\n};\n\nfunction flatArray(points, fx, fy, that) {\n  const n = points.length;\n  const array = new Float64Array(n * 2);\n  for (let i = 0; i < n; ++i) {\n    const p = points[i];\n    array[i * 2] = fx.call(that, p, i, points);\n    array[i * 2 + 1] = fy.call(that, p, i, points);\n  }\n  return array;\n}\n\nfunction* flatIterable(points, fx, fy, that) {\n  let i = 0;\n  for (const p of points) {\n    yield fx.call(that, p, i, points);\n    yield fy.call(that, p, i, points);\n    ++i;\n  }\n}\n","import { Delaunay } from \"d3-delaunay\";\n\nclass Cell {\n  constructor(i, voronoi) {\n    this.id = i\n    this.polygon = voronoi.cellPolygon(i);\n    this.path = new Path2D(voronoi.renderCell(i));\n    this.voronoi = voronoi;\n    this.fill = {\n      \"red\": 0,\n      \"green\": 128,\n      \"blue\": 255,\n      \"alpha\": 1.0\n    }\n    this.border = {\n      \"red\": 0,\n      \"green\": 255,\n      \"blue\": 255,\n      \"alpha\": 1.0\n    }\n    this.neighbors = [...voronoi.delaunay.neighbors(this.id)].filter(cell => this.borders(cell));\n  };\n\n  borders(cell) {\n    let id;\n    if (cell instanceof Cell) { id = cell.id } else { id = cell };\n    return this.polygon.some(([x, y]) => this.voronoi.cellPolygon(id).some(([x_, y_]) => x == x_ && y == y_));\n  }\n}\n\ndocument.addEventListener(\"DOMContentLoaded\", () => {\n  const canvasEl = document.getElementById(\"banner\");\n  const ctx = canvasEl.getContext(\"2d\");\n\n  canvasEl.width = self.innerWidth;\n  canvasEl.height = self.innerHeight;\n\n  let points = [];\n\n  const cellCount = points.length + (canvasEl.width * canvasEl.height / 2500);\n\n  for (let i = points.length; i < cellCount; i++) {\n    points.push([\n      Math.floor(canvasEl.width * Math.random()),\n      Math.floor(canvasEl.height * Math.random())\n    ]);\n  }\n\n  const delaunay = Delaunay.from(points)\n  const voronoi = delaunay.voronoi([0, 0, canvasEl.width, canvasEl.height]);\n\n  function drawVoronoi() {\n    voronoi.render(ctx);\n    ctx.fillStyle = \"rgba(0, 128, 255, 1.0)\"\n    ctx.fillRect(0, 0, canvasEl.width, canvasEl.height);\n    ctx.lineCap = 'round';\n    ctx.strokeStyle = \"rgba(0, 255, 255, 1.0)\"\n    ctx.lineWidth = 1;\n    ctx.stroke();\n  }\n\n  drawVoronoi();\n\n  const allCells = [];\n\n  for (let i = 0; i < cellCount; i++) {\n    allCells.push(new Cell(i, voronoi));\n  }\n\n  function getMousePos(canvasEl, e) {\n    let rect = canvasEl.getBoundingClientRect();\n    return {\n      x: e.clientX - rect.left,\n      y: e.clientY - rect.top\n    };\n  }\n\n  function fillCell(cell) {\n    ctx.fillStyle = `rgba(${cell.fill.red}, ${cell.fill.green}, ${cell.fill.blue}, ${cell.fill.alpha})`\n    ctx.strokeStyle = `rgba(${cell.border.red}, ${cell.border.green}, ${cell.border.blue}, ${cell.border.alpha})`\n    ctx.fill(cell.path);\n    ctx.stroke(cell.path);\n  }\n\n  function fillCells(cells) {\n    for (let cell of cells) {\n      fillCell(allCells[cell])\n    }\n  }\n\n  function colorCell(cell, fillColor, borderColor) {\n    cell.fill = { ...cell.fill, ...fillColor }\n    cell.border = borderColor;\n  }\n\n  function colorCells(cells, fillColor, borderColor) {\n    for (let cell of cells) {\n      colorCell(allCells[cell], fillColor, borderColor)\n    }\n  }\n\n  function highlightCell(cell, fillColor, borderColor) {\n    ctx.fillStyle = `rgba(${fillColor.red}, ${fillColor.green}, ${fillColor.blue}, ${fillColor.alpha})`\n    ctx.strokeStyle = `rgba(${borderColor.red}, ${borderColor.green}, ${borderColor.blue}, ${borderColor.alpha})`\n    ctx.fill(cell.path);\n    ctx.stroke(cell.path);\n  }\n\n  function highlightCells(cells, fillColor, borderColor) {\n    for (let cell of cells) {\n      colorCell(allCells[cell], fillColor, borderColor)\n    }\n  }\n\n  let prevHoverCell = allCells[0];\n  let currentHoverCell = allCells[0];\n  let painting = false;\n  let mouseButton = 0;\n\n  canvasEl.addEventListener('mousemove', (e) => {\n    let mousePos = getMousePos(canvasEl, e);\n    if (!voronoi.contains(currentHoverCell.id, mousePos.x, mousePos.y)) {\n      for (let cell of allCells) {\n        if (voronoi.contains(cell.id, mousePos.x, mousePos.y)) {\n          prevHoverCell = currentHoverCell;\n          currentHoverCell = cell;\n        };\n      }\n    }\n\n    if (currentHoverCell != prevHoverCell) {\n      highlightCell(currentHoverCell, currentHoverCell.fill, { red: 255, green: 255, blue: 255, alpha: 1.0 });\n    }\n  }, false);\n\n  canvasEl.addEventListener(\"mousedown\", (mouse) => {\n    mouse.preventDefault();\n    mouseButton = mouse.button;\n    painting = true;\n  }, false);\n\n  canvasEl.addEventListener('contextmenu', (mouse) => {\n    mouse.preventDefault();\n    mouseButton = mouse.button;\n    painting = true;\n  }, false);\n\n  canvasEl.addEventListener(\"mouseup\", () => {\n    painting = false;\n  }, false);\n\n  canvasEl.addEventListener(\"mouseout\", () => {\n    painting = false;\n  }, false);\n\n  window.setInterval(() => {\n    let rednesses = [];\n    for (let cell of allCells) {\n      rednesses.push(cell.neighbors.reduce((sum, neighbor) => {\n        return sum + allCells[neighbor].fill.red\n      }, 0) / cell.neighbors.length)\n    }\n    for (let i = 0; i < rednesses.length; i++) {\n      if (allCells[i] != currentHoverCell) {\n        if (allCells[i].fill.red < rednesses[i]) {\n          allCells[i].fill.red += 1;\n        } else if (allCells[i].fill.red > rednesses[i]) {\n          allCells[i].fill.red -= 1;\n        }\n        fillCell(allCells[i]);\n      }\n    }\n\n    if (painting) {\n      if (mouseButton == 0) { currentHoverCell.fill.red += 1 } else if (mouseButton == 2) { currentHoverCell.fill.red -= 1 };\n      fillCell(currentHoverCell);\n    }\n\n    highlightCell(currentHoverCell, currentHoverCell.fill, { red: 255, green: 255, blue: 255, alpha: 1.0 });\n  }, 10);\n\n});"],"sourceRoot":""}